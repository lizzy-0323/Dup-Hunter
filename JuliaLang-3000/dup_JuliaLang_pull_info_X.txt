[{"A_title": "Fix realpath on Windows", "A_clean_title": ["fix", "realpath", "window"], "B_title": "cleanup of Filesystem-related functions", "B_clean_title": ["cleanup", "filesystem", "relat", "function"], "A_body": "There was a small inefficiency that would usually cause the call to `GetFullPathName` to be made twice. See https://github.com/JuliaLang/julia/pull/13542#discussion-diff-41770705. \n", "A_clean_body": ["there", "wa", "small", "ineffici", "that", "would", "usual", "caus", "call", "getfullpathnam", "get", "full", "path", "name", "made", "twice", "see", "http", "github", "com", "julialang", "julia", "pull", "13542", "julia", "lang", "discuss", "diff", "41770705"], "B_body": "1) groups Filesystem-related functions into a new module \"Filesystem\" (was \"Base.FS\")\n2) deprecates isreadable/writable/executable for filesystem paths, closing #7385\n3) adds a few missing `isopen` tests\n", "B_clean_body": ["group", "filesystem", "relat", "function", "into", "new", "modul", "filesystem", "wa", "base", "fs", "deprec", "isread", "writabl", "execut", "filesystem", "path", "close", "7385", "add", "few", "miss", "isopen", "test"], "title_sim": [-0.02042979577402101], "body_sim": [0.11824516841041327], "file_list_sim": 0.05, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.07769423558897243, 0.7469879518072289], "pattern": -1, "time": 47}, {"A_title": "Initialize finalizer_list_marked", "A_clean_title": ["initi", "final", "list", "mark"], "B_title": "WIP: Clean up arraylist_t handling [ci skip][av skip]", "B_clean_title": ["wip", "clean", "up", "arraylist", "handl", "ci", "skip", "av", "skip"], "A_body": "Noticed this when I was checking https://github.com/JuliaLang/julia/issues/11814.\n\nThis doesn't cause a crash because `arraylist_grow` thinks the `items == NULL != &_space[0]` is a `malloc`'d array and called `realloc` on it (which is allowed).\n\nThe implementation seems to be robust against this but this IMHO should be fixed.\n\nNote that this does **not** fix #11814 \n", "A_clean_body": ["notic", "thi", "when", "wa", "check", "http", "github", "com", "julialang", "julia", "issu", "11814", "julia", "lang", "thi", "n't", "caus", "crash", "becaus", "arraylist", "grow", "think", "item", "null", "space", "malloc", "'d", "array", "call", "realloc", "it", "which", "allow", "implement", "seem", "robust", "against", "thi", "but", "thi", "imho", "fix", "note", "that", "thi", "**not**", "fix", "11814"], "B_body": "This compiles cleanly, but it crashes, and I haven't had time to look into it yet, but I thought it might give people an idea of just what I was saying, about changing the code to not depend ever on sticking integers into pointer values (at least for right now, for things using `arraylist_t`).\nMy digging into this has also exposed some things I'd like to ask about, where it looks like there is potential for memory leaks...\n", "B_clean_body": ["thi", "compil", "cleanli", "but", "it", "crash", "have", "n't", "had", "time", "look", "into", "it", "yet", "but", "thought", "it", "might", "give", "peopl", "idea", "just", "what", "wa", "say", "about", "chang", "code", "not", "depend", "ever", "stick", "integ", "into", "pointer", "valu", "at", "least", "right", "now", "thing", "arraylist", "my", "dig", "into", "thi", "ha", "also", "expos", "some", "thing", "'d", "like", "ask", "about", "where", "it", "look", "like", "there", "potenti", "memori", "leak"], "title_sim": [0.007959003797277318], "body_sim": [0.2660715076819354], "file_list_sim": 0.125, "overlap_files_len": 1, "code_sim": [0.05086882018758848, 0.1692705455163884], "location_sim": [0.0, 0.0], "pattern": 0, "time": 4}, {"A_title": "Convert stdlib to markdown.", "A_clean_title": ["convert", "stdlib", "markdown"], "B_title": "remove unnecessary doc string macros, re-sync documentation", "B_clean_title": ["remov", "unnecessari", "doc", "string", "macro", "re", "sync", "document"], "A_body": "This completes the conversion of the stdlib docstrings from a mixture of markdown and rst to just markdown.\n\nThis PR consists of the following:\n- split `helpdb.jl` into several smaller files based on which module they're from\n- add footnote parsing and rendering: `[^footnote]` and `[^footnote]: content`\n- add rst simple table rendering\n- transform links when outputting rst if they're `:func:`, `:ref:`, etc. This is a temporary measure until the manual is also converted to markdown when we can switch to @StefanKarpinski's plan for refs.\n- adds inline tex using the scholarly markdown syntax of double backticks and fenced code blocks with `language == \"math\"`\n- Reformatting of all docstrings in `Base` to remove rst blocks, wrap text at ~92 chars\n- adds a macro to `basedocs.jl` to make the `keyword` docstrings defined there appear more uniform with `@doc`, ie. docstring above the object being documented\n- regenerate the stdlib docs and make some minor fixes to correct for incorrectly escaped `\\`s\n\n`.. note::` syntax doesn't seem to have an equivalent in markdown so I've just made a basic change for now, a header called `**notes**``, I'll change to something else if anyone has a suggestion for formatting them differently.\n\n`make doctest` fails currently with incorrect backtrace linenumbers, nothing related to this PR I believe.\n\nThe best commit to review these changes is probably the last one, https://github.com/JuliaLang/julia/commit/5edce899ad027ea741c1898e75a7262652d2d411, most of the diff is just escaped backslash changes, which don't appear to affect the final docs in any way.\n", "A_clean_body": ["thi", "complet", "convers", "stdlib", "docstr", "mixtur", "markdown", "rst", "just", "markdown", "thi", "pr", "consist", "follow", "split", "helpdb", "jl", "into", "sever", "smaller", "file", "base", "which", "modul", "they", "'re", "add", "footnot", "pars", "render", "^footnot", "^footnot", "content", "add", "rst", "simpl", "tabl", "render", "transform", "link", "when", "output", "rst", "they", "'re", "func", "ref", "etc", "thi", "temporari", "measur", "until", "manual", "also", "convert", "markdown", "when", "we", "switch", "stefankarpinski", "stefan", "karpinski", "'s", "plan", "ref", "add", "inlin", "tex", "scholarli", "markdown", "syntax", "doubl", "backtick", "fenc", "code", "block", "languag", "math", "reformat", "all", "docstr", "base", "remov", "rst", "block", "wrap", "text", "at", "~92", "char", "add", "macro", "basedoc", "jl", "make", "keyword", "docstr", "defin", "there", "appear", "more", "uniform", "doc", "ie", "docstr", "abov", "object", "be", "document", "regener", "stdlib", "doc", "make", "some", "minor", "fix", "correct", "incorrectli", "escap", "note", "syntax", "n't", "seem", "have", "equival", "markdown", "so", "'ve", "just", "made", "basic", "chang", "now", "header", "call", "**notes**", "'ll", "chang", "someth", "anyon", "ha", "suggest", "format", "them", "differ", "make", "doctest", "fail", "current", "incorrect", "backtrac", "linenumb", "noth", "relat", "thi", "pr", "believ", "best", "commit", "review", "these", "chang", "probabl", "last", "one", "http", "github", "com", "julialang", "julia", "commit", "5edce899ad027ea741c1898e75a7262652d2d411", "julia", "lang", "most", "diff", "just", "escap", "backslash", "chang", "which", "n't", "appear", "affect", "final", "doc", "ani", "way"], "B_body": "", "B_clean_body": [], "title_sim": [0.037469943544836244], "body_sim": [0.0], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 4}, {"A_title": "`@threadcall`: run C functions in another thread", "A_clean_title": ["threadcal", "run", "function", "anoth", "thread"], "B_title": "WIP: ccall using libuv's threadpool", "B_clean_title": ["wip", "ccall", "libuv", "'s", "threadpool"], "A_body": "cc @amitmurthy \u2013\u00a0sorry this took me so long to get around to.\n", "A_clean_body": ["cc", "amitmurthi", "sorri", "thi", "took", "me", "so", "long", "get", "around"], "B_body": "Develops on ideas discussed in #12455 . @StefanKarpinski your work was really useful. \n\nYou need to export env variable UV_THREADPOOL_SIZE to set libuv's threadpool size before starting julia.  Default is 4.\n\nWorks for `sleep` with integer arguments\n\n```\nc_sleep = @wrapper sleep Cuint Cuint\n@sync begin\n    for i in 1:10\n        @async threadcall(c_sleep, i)\n    end\nend\n```\n\nBarfs on string arguments \n\n```\njulia> c_printf = @wrapper printf Cuint Cstring Cuint\nBase.CFunction{2}(Ptr{Void} @0x00007fdc41bc8290,UInt32,(Cstring,UInt32))\n\njulia> @sync begin\n           for i in 1:10\n               @async threadcall(c_printf, \"Hello from %d\\n\", i)\n           end\n       end\nERROR: MethodError(convert,(Cstring,\"Hello from %d\\n\"))\n in threadcall at util.jl:434\n in anonymous at task.jl:446\n\n...and 9 other exceptions.\n\n in sync_end at ./task.jl:412\n in anonymous at task.jl:421\n```\n", "B_clean_body": ["develop", "idea", "discuss", "12455", "stefankarpinski", "stefan", "karpinski", "your", "work", "wa", "realli", "use", "you", "need", "export", "env", "variabl", "uv", "threadpool", "size", "set", "libuv", "'s", "threadpool", "size", "befor", "start", "julia", "default", "work", "sleep", "integ", "argument", "sleep", "wrapper", "sleep", "cuint", "cuint", "sync", "begin", "1:10", "async", "threadcal", "sleep", "end", "end", "barf", "string", "argument", "julia", "printf", "wrapper", "printf", "cuint", "cstring", "cuint", "base", "cfunction", "function", "ptr", "void", "0x00007fdc41bc8290", "uint32", "int32", "cstring", "uint32", "int32", "julia", "sync", "begin", "1:10", "async", "threadcal", "printf", "hello", "end", "end", "error", "methoderror", "method", "error", "convert", "cstring", "hello", "threadcal", "at", "util", "jl:434", "anonym", "at", "task", "jl:446", "other", "except", "sync", "end", "at", "jl:412", "task", "anonym", "at", "task", "jl:421"], "title_sim": [0.03404094753253126], "body_sim": [0.05486051175635891], "file_list_sim": 0.3333333333333333, "overlap_files_len": 2, "code_sim": [0.986749965570788, 0.986749965570788], "location_sim": [0.0, 0.0], "pattern": 0, "time": 119}, {"A_title": "RFC: Moderately improved dict printing", "A_clean_title": ["rfc", "moder", "improv", "dict", "print"], "B_title": "Key and value iterators show their contents on the REPL", "B_clean_title": ["key", "valu", "iter", "show", "their", "content", "repl"], "A_body": "This is a modest attempt at improving the situation for issue #1759.  I've added\nslightly enhanced `summary`s with information about the number of k/v pairs for\nAssociative and Key/ValueIterator types.\n\nI'm still slightly confused by all the different methods used for show, but\nthis PR keeps the old behavior (mostly) as `showcompact`. I then added new\nfunctionality in `show` and `showlimited`, using newlines as delimiters between\nkey/value pairs.  When output is limited, values are truncated at newlines or\nthe TTY screen edge and a limited number of pairs are printed.\n\nThe key and value iterators no longer spit out entire dictionaries when shown.\nThey instead show a limited `{}` array of the keys and values.\n", "A_clean_body": ["thi", "modest", "attempt", "at", "improv", "situat", "issu", "1759", "'ve", "ad", "slightli", "enhanc", "summari", "inform", "about", "number", "pair", "associ", "key", "valueiter", "valu", "iter", "type", "'m", "still", "slightli", "confus", "by", "all", "differ", "method", "use", "show", "but", "thi", "pr", "keep", "old", "behavior", "mostli", "as", "showcompact", "then", "ad", "new", "function", "show", "showlimit", "newlin", "as", "delimit", "between", "key", "valu", "pair", "when", "output", "limit", "valu", "are", "truncat", "at", "newlin", "or", "tti", "screen", "edg", "limit", "number", "pair", "are", "print", "key", "valu", "iter", "no", "longer", "spit", "out", "entir", "dictionari", "when", "shown", "they", "instead", "show", "limit", "array", "key", "valu"], "B_body": "@simonster suggested this idea. Since showing a key iterator on the REPL is currently dumping the whole dictionary using the most generic `show` routine, it seems we might as well show just the dictionary keys. A frequent complaint about Python 3 is that its inconvenient to inspect dictionaries on the REPL since you constantly forced to collect the key iterators, so why not avoid that. \n", "B_clean_body": ["simonst", "suggest", "thi", "idea", "sinc", "show", "key", "iter", "repl", "current", "dump", "whole", "dictionari", "most", "gener", "show", "routin", "it", "seem", "we", "might", "as", "well", "show", "just", "dictionari", "key", "frequent", "complaint", "about", "python", "that", "it", "inconveni", "inspect", "dictionari", "repl", "sinc", "you", "constantli", "forc", "collect", "key", "iter", "so", "whi", "not", "avoid", "that"], "title_sim": [0.0024611834431245015], "body_sim": [0.5385701611399711], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 10}, {"A_title": "Documentation System", "A_clean_title": ["document", "system"], "B_title": "WIP/RFC: metadata implemented, REPL-help ported, user-made doc now possible (issue #3988)", "B_clean_title": ["wip", "rfc", "metadata", "implement", "repl", "help", "port", "user", "made", "doc", "now", "possibl", "issu", "3988"], "A_body": "A metadata system for global objects + pretty markdown parsing and display (see the [readme](https://github.com/one-more-minute/Markdown.jl)). For example:\n\n``` julia\n@doc \"\"\"\n... flowing rivers of technical poetry ...\n\"\"\" ->\nfunction foo() ...\n```\n\nDocumenting multiple methods of a function will concatenate the doc strings together, in the order the methods were originally defined, and this is overloadable.\n\nBy default `@doc` treats unadorned strings as equivalent to `md\"\"` (i.e. markdown syntax) but you can actually put anything before the arrow to associate it with the function.\n\nDocs can be queried with e.g.\n\n``` julia\ndoc(Docs.doc)\n@doc Docs.doc\n@doc @doc # For macros\n@doc text\"\"\n```\n\n(and you can try these out on this branch \u2013\u00a0the repl help key `?` will work too)\n\nGeneral Todos:\n- [ ] Prettier syntax (`\"...\"` -> `@doc doc\"...\" ->`)\n- [ ] Add `Docs.@init` call to module init code\n- [x] REPL `?` integration\n- [x] Make sure exports are present and correct\n- [ ] Move away from the current help system and deprecate it\n- [ ] Fix the segfault when `Text` docs are uncommented (!?)\n", "A_clean_body": ["metadata", "system", "global", "object", "pretti", "markdown", "pars", "display", "see", "readm", "http", "more", "jl", "github", "com", "one", "minut", "markdown", "exampl", "julia", "doc", "flow", "river", "technic", "poetri", "function", "foo", "document", "multipl", "method", "function", "will", "concaten", "doc", "string", "togeth", "order", "method", "were", "origin", "defin", "thi", "overload", "by", "default", "doc", "treat", "unadorn", "string", "as", "equival", "md", "markdown", "syntax", "but", "you", "actual", "put", "anyth", "befor", "arrow", "associ", "it", "function", "doc", "queri", "julia", "doc", "doc", "doc", "doc", "doc", "doc", "doc", "doc", "macro", "doc", "text", "you", "tri", "these", "out", "thi", "branch", "repl", "help", "key", "will", "work", "too", "gener", "todo", "prettier", "syntax", "doc", "doc", "add", "doc", "init", "call", "modul", "init", "code", "repl", "integr", "make", "sure", "export", "are", "present", "correct", "move", "away", "current", "help", "system", "deprec", "it", "fix", "segfault", "when", "text", "doc", "are", "uncom"], "B_body": "(updated 30 Jan)\n\nI added basic support to associate metadata with most objects using @stevengj's suggested global dict as backend. It is really rather quite trivial but seems to work fine (except below issues).  I use a function interface to the `META` dict so the backend could be changed. So, main thing here is whether we're happy with that function-interface or not.\n\nAs illustration of its power ;-), I ported the existing REPL-help system over into this system and it works as before, except that user-made help is now possible. I'll post a usage-demo to #3988.  The help system as in this pull-request is _not_ meant to stay like that.  It's thought as a transitional state to something fancy.\n\nSo:\n1) Added basic support to associate metadata to most objects. The data is stored in the `ObjectIdDict` `Base.META`.  However, interaction should be done through the functions:  `getmeta`, `setmeta!` & `hasmeta`\n\n2) Ported the existing REPL-help system over to work with this system.\n- `help` and `?` work as before (except 3-objects don't work, see test/help.jl)\n- user-made help is now possible through a `@doc`-macro and `doc`-function\n- Documentation of objects is kept in the metadata storage.\n   Documentation of non-objects, e.g. keywords, and macros\n   is kept in: `Base.Help.NONOBJ_DICT`.\n\nIssues:\n- every now and then I get a `ERROR: BoundsError()` when initializing the help from helpdb.jl\n- There is a strange bug with `eval` not picking up its documentation, no idea why.\n- how can macros be referred to, other than representing them as a string?\n  - I use now a separate Dict with string-keys for documenting macros and non-objects: keywords, `&&`, etc.\n- should some functions take the metadata into account? Examples are:\n  - `copy`, `deepcopy`, `sizeof`\n", "B_clean_body": ["updat", "30", "jan", "ad", "basic", "support", "associ", "metadata", "most", "object", "stevengj", "'s", "suggest", "global", "dict", "as", "backend", "it", "realli", "rather", "quit", "trivial", "but", "seem", "work", "fine", "except", "below", "issu", "use", "function", "interfac", "meta", "dict", "so", "backend", "could", "chang", "so", "main", "thing", "here", "whether", "we", "'re", "happi", "that", "function", "interfac", "or", "not", "as", "illustr", "it", "power", "port", "exist", "repl", "help", "system", "over", "into", "thi", "system", "it", "work", "as", "befor", "except", "that", "user", "made", "help", "now", "possibl", "'ll", "post", "usag", "demo", "3988", "help", "system", "as", "thi", "pull", "request", "not", "meant", "stay", "like", "that", "it", "'s", "thought", "as", "transit", "state", "someth", "fanci", "so", "ad", "basic", "support", "associ", "metadata", "most", "object", "data", "store", "objectiddict", "object", "id", "dict", "base", "meta", "howev", "interact", "done", "through", "function", "getmeta", "setmeta", "hasmeta", "port", "exist", "repl", "help", "system", "over", "work", "thi", "system", "help", "work", "as", "befor", "except", "object", "n't", "work", "see", "jl", "test", "help", "user", "made", "help", "now", "possibl", "through", "doc", "macro", "doc", "function", "document", "object", "kept", "metadata", "storag", "document", "non", "object", "keyword", "macro", "kept", "base", "help", "nonobj", "dict", "issu", "everi", "now", "then", "get", "error", "boundserror", "bound", "error", "when", "initi", "help", "helpdb", "jl", "there", "strang", "bug", "eval", "not", "pick", "up", "it", "document", "no", "idea", "whi", "how", "macro", "refer", "other", "than", "repres", "them", "as", "string", "use", "now", "separ", "dict", "string", "key", "document", "macro", "non", "object", "keyword", "etc", "some", "function", "take", "metadata", "into", "account", "exampl", "are", "copi", "deepcopi", "sizeof"], "title_sim": [-0.005396456873396984], "body_sim": [0.3129952017234586], "file_list_sim": 0.125, "overlap_files_len": 3, "code_sim": [0.0, 0.0], "location_sim": [0.07070279424216766, 0.4394736842105263], "pattern": 0, "time": 269}, {"A_title": "dlopen should follow platform default behavior", "A_clean_title": ["dlopen", "follow", "platform", "default", "behavior"], "B_title": "test: add basic dlload tests", "B_clean_title": ["test", "add", "basic", "dlload", "test"], "A_body": "For OSX the default behavior is to dlopen with `RTLD_GLOBAL` while\non most other POSIX platforms the default is `RTLD_LOCAL`.  This reverts\nthe behavior introduced in #11352 which made `RTLD_LOCAL` the default for\nall platforms which caused issues when loading shared libraries on OSX.\n\nThis PR also cleans up some `Libdl` behavior and adds tests for the\n`Libdl` module.  `Libdl.dlopen` now prints a detailed error message in\nthe thrown exception rather than printing to STDERR.  `Libdl.dlsym` now\nthrows an exception instead of printing an error message to STDERR if\nthe symbol is not found in the shared library.  `RTLD_*` enum values now\nstart at 1 instead of 0 to reflect the fact that `RTLD_LOCAL` is not\nuniversal default behavior for POSIX platforms and needs to be detected on\nOSX.\n\ncc: @vtjnash, @poulson\n\ncloses #11692\nfixes #11689\nfixes #11322\n", "A_clean_body": ["osx", "default", "behavior", "dlopen", "rtld", "global", "while", "most", "other", "posix", "platform", "default", "rtld", "local", "thi", "revert", "behavior", "introduc", "11352", "which", "made", "rtld", "local", "default", "all", "platform", "which", "caus", "issu", "when", "load", "share", "librari", "osx", "thi", "pr", "also", "clean", "up", "some", "libdl", "behavior", "add", "test", "libdl", "modul", "libdl", "dlopen", "now", "print", "detail", "error", "messag", "thrown", "except", "rather", "than", "print", "stderr", "libdl", "dlsym", "now", "throw", "except", "instead", "print", "error", "messag", "stderr", "symbol", "not", "found", "share", "librari", "rtld", "enum", "valu", "now", "start", "at", "instead", "reflect", "fact", "that", "rtld", "local", "not", "univers", "default", "behavior", "posix", "platform", "need", "detect", "osx", "cc", "vtjnash", "poulson", "close", "11692", "fix", "11689", "fix", "11322"], "B_body": "Add some tests for the current `dlopen`/`jl_load_dynamic_library` behaviors as a baseline (ref https://github.com/JuliaLang/julia/pull/11488#issuecomment-108020747). Obviously dl loading is heavily tested by the whole system, but the intent here is to be explicit about the search help we provide on top of the system `dlopen`.\n\nThe final test is slightly convoluted and intentionally commented out right now as it [currently fails](https://github.com/JuliaLang/julia/pull/11488#issuecomment-108020444).\n", "B_clean_body": ["add", "some", "test", "current", "dlopen", "jl", "load", "dynam", "librari", "behavior", "as", "baselin", "ref", "http", "github", "com", "julialang", "julia", "pull", "11488", "julia", "lang", "issuecom", "108020747", "obvious", "dl", "load", "heavili", "test", "by", "whole", "system", "but", "intent", "here", "explicit", "about", "search", "help", "we", "provid", "top", "system", "dlopen", "final", "test", "slightli", "convolut", "intent", "comment", "out", "right", "now", "as", "it", "current", "fail", "http", "github", "com", "julialang", "julia", "pull", "11488", "julia", "lang", "issuecom", "108020444"], "title_sim": [0.028593760391242725], "body_sim": [0.18323715301044602], "file_list_sim": 0.25, "overlap_files_len": 2, "code_sim": [0.0, 0.0], "location_sim": [0.21957040572792363, 0.7419354838709677], "pattern": -1, "time": 18}, {"A_title": "let's release this thing !", "A_clean_title": ["let", "'s", "releas", "thi", "thing"], "B_title": "helpdb.jl: Turn :: into explicit code blocks", "B_clean_title": ["helpdb", "jl", "turn", "into", "explicit", "code", "block"], "A_body": "everyone cheer, Jake is near the finish line\n- [x] Rendering of `Mmap.*`\n- [ ] Sphinx search result/permalink of `Base.process_messages`\n- [ ] Sphinx search result for macros (e.g. `@assert` `@nloops`)\n- [ ] Stdlib doc for the doc system?\n- [x] `@repl` documentation for macrocalls\n", "A_clean_body": ["everyon", "cheer", "jake", "near", "finish", "line", "render", "mmap", "sphinx", "search", "result", "permalink", "base", "process", "messag", "sphinx", "search", "result", "macro", "assert", "nloop", "stdlib", "doc", "doc", "system", "repl", "document", "macrocal"], "B_body": "Avoids Sphinx getting upset or incorrectly parsing :: blocks\n\nNote: There are still blocks in the manual using :: that are preceded with comments\n\n``` rst\n.. Docstring generated from Julia source\n```\n\nAre these autogenerated somewhere? I couldn't find a script that extracted these blocks. @one-more-minute\n", "B_clean_body": ["avoid", "sphinx", "get", "upset", "or", "incorrectli", "pars", "block", "note", "there", "are", "still", "block", "manual", "that", "are", "preced", "comment", "rst", "docstr", "gener", "julia", "sourc", "are", "these", "autogener", "somewher", "could", "n't", "find", "script", "that", "extract", "these", "block", "one", "more", "minut"], "title_sim": [0.040004532865033526], "body_sim": [-0.0005775991499163181], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 3}, {"A_title": "Don't declare nested anonymous types", "A_clean_title": ["n't", "declar", "nest", "anonym", "type"], "B_title": "IO fixes", "B_clean_title": ["io", "fix"], "A_body": "This addresses this warning:\n./julia.h:78:9: warning: anonymous types declared in an anonymous union are an\n      extension [-Wnested-anon-types]\n        struct {\n", "A_clean_body": ["thi", "address", "thi", "warn", "h:78:9", "julia", "warn", "anonym", "type", "declar", "anonym", "union", "are", "extens", "wnest", "anon", "type", "struct"], "B_body": "just going back through old IO issues and trying to close a few\n", "B_clean_body": ["just", "go", "back", "through", "old", "io", "issu", "tri", "close", "few"], "title_sim": [0.04138911365783284], "body_sim": [-0.013289281555514228], "file_list_sim": 0.05263157894736842, "overlap_files_len": 1, "code_sim": [0.21455770192845083, 0.6520102118093503], "location_sim": [0.08516483516483517, 1.0], "pattern": 0, "time": 1}, {"A_title": "move hidden fields of leaftype datatypes into a separate struct", "A_clean_title": ["move", "hidden", "field", "leaftyp", "datatyp", "into", "separ", "struct"], "B_title": "Determine the size of field descriptors using a estimated type size", "B_clean_title": ["determin", "size", "field", "descriptor", "estim", "type", "size"], "A_body": "this shaves a sizeable amount off the system image (almost 10%)\n", "A_clean_body": ["thi", "shave", "sizeabl", "amount", "off", "system", "imag", "almost", "10"], "B_body": "This fixes https://github.com/JuliaLang/julia/issues/11884 .\n1. Passing too many arguments to a function or constructing a structure/tuple of GB's size is arguably not a good idea. The primary goal of this PR is not to encourage that but I do feel like the current limit `16`bit integer is a little bit too small.\n2. This does **not** solve the problem in issue #11320 (hopefully github's close issue hook does not pick this one up) so passing big tuples around / constructing them might still be an issue. On the other hand, this change should be almost orthogonal to that issue and won't make the situation much worse.\n3. The current limit is `2^31 - 1` and this is mainly because `DataType.size` is a `Int32`. According to @jiahao , this was because of not letting unsigned integer types polluting calculations. It might not be a problem now anymore but I think this limit should be good enough for now and I don't want to risk introducing subtle type stability issues.\n", "B_clean_body": ["thi", "fix", "http", "github", "com", "julialang", "julia", "issu", "11884", "julia", "lang", "pass", "too", "mani", "argument", "function", "or", "construct", "structur", "tupl", "gb", "'s", "size", "arguabl", "not", "good", "idea", "primari", "goal", "thi", "pr", "not", "encourag", "that", "but", "feel", "like", "current", "limit", "16", "bit", "integ", "littl", "bit", "too", "small", "thi", "**not**", "solv", "problem", "issu", "11320", "hope", "github", "'s", "close", "issu", "hook", "not", "pick", "thi", "one", "up", "so", "pass", "big", "tupl", "around", "construct", "them", "might", "still", "issu", "other", "hand", "thi", "chang", "almost", "orthogon", "that", "issu", "wo", "n't", "make", "situat", "much", "wors", "current", "limit", "2^31", "thi", "mainli", "becaus", "datatyp", "size", "data", "type", "int32", "accord", "jiahao", "thi", "wa", "becaus", "not", "let", "unsign", "integ", "type", "pollut", "calcul", "it", "might", "not", "problem", "now", "anymor", "but", "think", "thi", "limit", "good", "enough", "now", "n't", "want", "risk", "introduc", "subtl", "type", "stabil", "issu"], "title_sim": [0.2560049952414114], "body_sim": [0.09353331732128169], "file_list_sim": 0.037037037037037035, "overlap_files_len": 1, "code_sim": [0.11697288948854996, 0.18215326543120697], "location_sim": [0.09156193895870736, 0.34615384615384615], "pattern": 0, "time": 370}, {"A_title": "Add functions nparams, getparam to access type parameters", "A_clean_title": ["add", "function", "nparam", "getparam", "access", "type", "paramet"], "B_title": "RFC: Make Tuple types with defined lengths iterable", "B_clean_title": ["rfc", "make", "tupl", "type", "defin", "length", "iter"], "A_body": "", "A_clean_body": [], "B_body": "More abstract tuple types like `Tuple` or `NTuple` (without parameters) and vararg tuples remain without any iteration methods defined.\n\nThis is something I'd really like to see, but I understand that it may be contentious.  For the most part this is fairly straightforward, but I did discover one minor confusion stemming from a definition for `eltype` for NTuples of all the same type.  Since eltype works in the type domain, there is no way to tell whether `eltype{N,T}(::Type{NTuple{N,T}})` should be `T` or `Type{T}`. I have removed these definitions.  This broke one unrelated test, since `collect((1,2,3))` is now `Any[1,2,3]`, and indexing with an `Any` array isn't implemented.\n", "B_clean_body": ["more", "abstract", "tupl", "type", "like", "tupl", "or", "ntupl", "tupl", "without", "paramet", "vararg", "tupl", "remain", "without", "ani", "iter", "method", "defin", "thi", "someth", "'d", "realli", "like", "see", "but", "understand", "that", "it", "may", "contenti", "most", "part", "thi", "fairli", "straightforward", "but", "did", "discov", "one", "minor", "confus", "stem", "definit", "eltyp", "ntupl", "tupl", "all", "same", "type", "sinc", "eltyp", "work", "type", "domain", "there", "no", "way", "tell", "whether", "eltyp", ":type", "ntupl", "tupl", "or", "type", "have", "remov", "these", "definit", "thi", "broke", "one", "unrel", "test", "sinc", "collect", "1,2,3", "now", "ani", "1,2,3", "index", "ani", "array", "n't", "implement"], "title_sim": [0.12411674573849457], "body_sim": [0.0], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 101}, {"A_title": "display complex UniformScaling with parentheses", "A_clean_title": ["display", "complex", "uniformsc", "uniform", "scale", "parenthes"], "B_title": "fix #22168, `im*I+I` should be shown as `(1+1im)*I`", "B_clean_title": ["fix", "22168", "im*i+i", "shown", "as", "1+1im", "*i"], "A_body": "fixes #22168", "A_clean_body": ["fix", "22168"], "B_body": "", "B_clean_body": [], "title_sim": [-0.0012862530228516203], "body_sim": [0.0], "file_list_sim": 0.5, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.75, 1.0], "pattern": 1, "time": 4}, {"A_title": "Try to synchronize threads initializations", "A_clean_title": ["tri", "synchron", "thread", "initi"], "B_title": "use sigwait for thread-safe and multi-thread-aware signal handling", "B_clean_title": ["use", "sigwait", "thread", "safe", "multi", "thread", "awar", "signal", "handl"], "A_body": "Using `uv_barrier_wait` as @tkelman suggested in https://github.com/JuliaLang/julia/issues/14091#issuecomment-158716274 . I've also thought about `ti_threadgroup_barrier` but I'm not sure if it is available at this point (without introducing more race conditions)....\n\nTested on top of #14083 and it seems to fix the segfault for me.\n\nFixes #14091 \n", "A_clean_body": ["uv", "barrier", "wait", "as", "tkelman", "suggest", "http", "github", "com", "julialang", "julia", "issu", "14091", "julia", "lang", "issuecom", "158716274", "'ve", "also", "thought", "about", "ti", "threadgroup", "barrier", "but", "'m", "not", "sure", "it", "avail", "at", "thi", "point", "without", "introduc", "more", "race", "condit", "test", "top", "14083", "it", "seem", "fix", "segfault", "me", "fix", "14091"], "B_body": "this is a redesign of the unix signal handling so that it will be more thread-safe and extensible.\n\nyyc: Close https://github.com/JuliaLang/julia/issues/14091\n", "B_clean_body": ["thi", "redesign", "unix", "signal", "handl", "so", "that", "it", "will", "more", "thread", "safe", "extens", "yyc", "close", "http", "github", "com", "julialang", "julia", "issu", "14091", "julia", "lang"], "title_sim": [0.5241200330022886], "body_sim": [0.3824262123375091], "file_list_sim": 0.05, "overlap_files_len": 1, "code_sim": [0.36697273035554645, 0.5069332425183865], "location_sim": [0.03186968838526912, 0.36585365853658536], "pattern": 1, "time": 81}, {"A_title": "Fix type intersection of NTuple's", "A_clean_title": ["fix", "type", "intersect", "ntupl", "tupl", "'s"], "B_title": "NTuples made me sad (so I nixed them)", "B_clean_title": ["ntupl", "tupl", "made", "me", "sad", "so", "nix", "them"], "A_body": "The type intersection of `NTuple{N, Int}` and `NTuple{N, Float64}` should be `Tuple{}`\n\nThis also give a ambiguity warning with the following function definitions\n\n``` julia\njulia> f{N}(::NTuple{N, Int}) = 1\nf (generic function with 1 method)\n\njulia> f{N}(::NTuple{N, Float64}) = 2\nWarning: New definition \n    f(NTuple{#N<:Any, Float64}) at none:1\nis ambiguous with: \n    f(NTuple{#N<:Any, Int64}) at none:1.\nTo fix, define \n    f(Tuple{})\nbefore the new definition.\nf (generic function with 2 methods)\n```\n", "A_clean_body": ["type", "intersect", "ntupl", "tupl", "int", "ntupl", "tupl", "float64", "tupl", "thi", "also", "give", "ambigu", "warn", "follow", "function", "definit", "julia", "julia", ":ntupl", ":n", "tupl", "int", "gener", "function", "method", "julia", ":ntupl", ":n", "tupl", "float64", "warn", "new", "definit", "ntupl", "tupl", "ani", "float64", "at", "none:1", "ambigu", "ntupl", "tupl", "ani", "int64", "at", "none:1", "fix", "defin", "tupl", "befor", "new", "definit", "gener", "function", "method"], "B_body": "This rabbit hole turned out to be a giant dungeon, ~~instead, and I haven't yet found the exit. I think I'm very close, but I've spent far too much time on this and I'm beginning to run out of ideas and energy.~~, but yay, I found the exit.\n\nThis is the latest attempt at `NTuple{N,T} -> Tuple{Vararg{T,N}}`, aka #10911, #10691. Julia builds and passes ~~many~~ all tests, ~~but borks on some (e.g., `subarray`). The current problem seems to be that a `VarState(Tuple{_<:Vararg{T,N}},false)` gets injected somewhere (leading ultimately to an attempted `Tuple{Vararg, ASCIIString}` and `Vararg type in non-final position` error). It's probably a 3-line fix, but I have not yet succeeded in finding the correct 3 lines (inference.jl is difficult for not-Jeff to hack on).~~\n\n~~This still contains~~The intermediate commits contain a lot of debugging code that ~~will eventually be~~ was deleted in the later commits. In the end, the way I got this ~~far~~to work was to write new versions of `jl_intersect_type`, `jl_subtype_le`, `type_morespecific`, and `type_match_`, which (1) called the old algorithm and stored the result, then (2) translated NTuples on-the-fly and then called the new algorithm with the translated arguments, and (3) printed some output if the two disagreed. ~~This branch is partway through the deletion of all that debugging code; before completing the migration I'd love to figure out where the problem is.~~\n\nIt turns out that we have enough differences in how `NTuple`s and `Tuple{Vararg}`s behave that some disagreements are unavoidable; one of the best things about this, presumably, is that such differences will go away. I even went to the trouble to catalog the differences; in the \"best\" column I use \"N\" to indicate that I think the new algorithm yields the most sensible result, and \"O\" to indicate the old algorithm. Only two of those four algorithms had differences, of which representative examples are:\n\n`jl_intersect_type`:\nnone (as measured by a <: b && b <: a)\n\n`jl_subtype_le`:\n\n| a | b | ta | invariant | old result | new result | best |\n| --- | --- | --- | --- | --- | --- | --- |\n| `_<:Tuple` | `Tuple` | 0 | 0 | 0 | 1 | N |\n| `_<:Tuple{_<:Vararg{T<:Any, N<:Any}}` | `Tuple{Vararg{#T<:Any, N<:Any}}` | 0 | 0 | 0 | 1 | N? |\n| `Tuple{}` | `NTuple{#_<:Any, #T<:Any}` | 0 | 1 | 1 | ~~0~~1 | ~~O~~same |\n| `Tuple{Tuple{_<:Tuple{Any, Any}}}` | `Tuple{Tuple{Tuple{Any, Any}}}` | 0 | 0 | 0 | 1 | N? |\n| `_<:Tuple{Vararg{Int64, #N<:Any}}` | `Tuple{Vararg{#T<:Any, #_<:Any}}` | 0 | 0 | 0 | 1 | N? |\n| `Tuple{Symbol, Integer}` | `Tuple{Vararg{#T<:Any, N<:Any}}` | 0 | 1 | 0 | 1 | ? |\n| `Tuple{Char, Char}` | `Tuple{Vararg{#T<:Any, N<:Any}}` | 0 | 1 | 0 | 1 | N |\n| `Tuple{Type{Tuple{Int64, Int64}}}` | `Tuple{Type{Tuple{Int64, Vararg{Int64, N<:Any}}}}` | 0 | 0 | 0 | 1 | N? |\n| `Tuple{Type{Tuple{Char}}, Tuple{Vararg{Any, N<:Any}}}` | `Tuple{Type{Tuple{Vararg{#T<:Any, N<:Any}}}, Tuple}` | 0 | 0 | 0 | 1 | N |\n| `Tuple{Tuple{_<:Tuple{Vararg{Any, N<:Any}}}, Int64}` | `Tuple{Tuple{Tuple{Vararg{Any, N<:Any}}}, Int64}` | 0 | 0 | 0 | 1 | N? |\n| `Tuple{Tuple{Symbol, Vararg{Symbol, N<:Any}}, DataType, Type{T<:Any}}` | `Tuple{Vararg{#T<:Any, N<:Any}}` | 0 | 1 | 0 | 1 | N |\n| `_<:Tuple{Symbol, Vararg{Symbol, N<:Any}}` | `Tuple` | 0 | 0 | 0 | 1 | N |\n| `Tuple{DataType, Type}` | `Tuple{Vararg{#T<:Any, N<:Any}}` | 0 | 1 | 0 | 1 | N? |\n| `_<:Tuple{Tuple{Symbol, Vararg{Symbol, N<:Any}}, DataType, Type{T<:Any}}` | `Tuple{Tuple{Vararg{Any, N<:Any}}, DataType, Vararg{Any, N<:Any}}` | 0 | 0 | 0 | 1 | N? |\n| `Tuple{Type{Tuple{Type{Base.IteratorsMD.CartesianIndex}, Tuple{Int64, Int64, Int64}}}, UInt64}` | `Tuple{Type{Tuple{Type{Base.IteratorsMD.CartesianIndex}, Tuple{Vararg{Int64, N<:Any}}}}, UInt64}` | 0 | 0 | 0 | 1 | N? |\n\n`jl_type_morespecific`:\nnone\n\n`type_match_`:\n\n| child | parent | morespecific | invariant | old result | new result | best |\n| --- | --- | --- | --- | --- | --- | --- |\n| `NTuple{#N<:Any, Int}` | `NTuple{#N<:Any, Integer}` | 0 | 0 | 0 | 1 | N |\n| `Tuple{Ptr{#T<:Any}, NTuple{#N<:Any, Int64}}` | `Tuple{Ptr{#T<:Any}, NTuple{#N<:Any, Integer}}` | 1 | 0 | 0 | 1 | N |\n\nNote that ~~in only one case does~~there are no cases where the result in current master seems to make more sense to me than the version here. I think there's some chance that, once working, this will fix some ambiguity and similar problems.\n", "B_clean_body": ["thi", "rabbit", "hole", "turn", "out", "giant", "dungeon", "~~instead", "have", "n't", "yet", "found", "exit", "think", "'m", "veri", "close", "but", "'ve", "spent", "far", "too", "much", "time", "thi", "'m", "begin", "run", "out", "idea", "energi", "but", "yay", "found", "exit", "thi", "latest", "attempt", "at", "ntupl", "tupl", "tupl", "vararg", "aka", "10911", "10691", "julia", "build", "pass", "~~many~~", "all", "test", "~~but", "bork", "some", "subarray", "current", "problem", "seem", "that", "varstat", "var", "state", "tupl", "vararg", "fals", "get", "inject", "somewher", "lead", "ultim", "attempt", "tupl", "vararg", "asciistr", "ascii", "string", "vararg", "type", "non", "final", "posit", "error", "it", "'s", "probabl", "line", "fix", "but", "have", "not", "yet", "succeed", "find", "correct", "line", "infer", "jl", "difficult", "not", "jeff", "hack", "~~thi", "still", "contains~~th", "intermedi", "commit", "contain", "lot", "debug", "code", "that", "~~will", "eventu", "be~~", "wa", "delet", "later", "commit", "end", "way", "got", "thi", "~~far~~to", "work", "wa", "write", "new", "version", "jl", "intersect", "type", "jl", "subtyp", "le", "type", "morespecif", "type", "match", "which", "call", "old", "algorithm", "store", "result", "then", "translat", "ntupl", "tupl", "fli", "then", "call", "new", "algorithm", "translat", "argument", "print", "some", "output", "two", "disagre", "~~thi", "branch", "partway", "through", "delet", "all", "that", "debug", "code", "befor", "complet", "migrat", "'d", "love", "figur", "out", "where", "problem", "it", "turn", "out", "that", "we", "have", "enough", "differ", "how", "ntupl", "tupl", "tupl", "vararg", "behav", "that", "some", "disagr", "are", "unavoid", "one", "best", "thing", "about", "thi", "presum", "that", "such", "differ", "will", "go", "away", "even", "went", "troubl", "catalog", "differ", "best", "column", "use", "indic", "that", "think", "new", "algorithm", "yield", "most", "sensibl", "result", "indic", "old", "algorithm", "onli", "two", "those", "four", "algorithm", "had", "differ", "which", "repres", "exampl", "are", "jl", "intersect", "type", "none", "as", "measur", "by", "jl", "subtyp", "le", "ta", "invari", "old", "result", "new", "result", "best", "tupl", "tupl", "tupl", "vararg", "ani", "ani", "tupl", "vararg", "ani", "ani", "tupl", "ntupl", "tupl", "ani", "ani", "~~0~~1", "~~o~~sam", "tupl", "tupl", "tupl", "ani", "ani", "tupl", "tupl", "tupl", "ani", "ani", "tupl", "vararg", "int64", "ani", "tupl", "vararg", "ani", "ani", "tupl", "symbol", "integ", "tupl", "vararg", "ani", "ani", "tupl", "char", "char", "tupl", "vararg", "ani", "ani", "tupl", "type", "tupl", "int64", "int64", "tupl", "type", "tupl", "int64", "vararg", "int64", "ani", "tupl", "type", "tupl", "char", "tupl", "vararg", "ani", "ani", "tupl", "type", "tupl", "vararg", "ani", "ani", "tupl", "tupl", "tupl", "tupl", "vararg", "ani", "ani", "int64", "tupl", "tupl", "tupl", "vararg", "ani", "ani", "int64", "tupl", "tupl", "symbol", "vararg", "symbol", "ani", "datatyp", "data", "type", "type", "ani", "tupl", "vararg", "ani", "ani", "tupl", "symbol", "vararg", "symbol", "ani", "tupl", "tupl", "datatyp", "data", "type", "type", "tupl", "vararg", "ani", "ani", "tupl", "tupl", "symbol", "vararg", "symbol", "ani", "datatyp", "data", "type", "type", "ani", "tupl", "tupl", "vararg", "ani", "ani", "datatyp", "data", "type", "vararg", "ani", "ani", "tupl", "type", "tupl", "type", "base", "iteratorsmd", "cartesianindex", "iter", "md", "cartesian", "index", "tupl", "int64", "int64", "int64", "uint64", "int64", "tupl", "type", "tupl", "type", "base", "iteratorsmd", "cartesianindex", "iter", "md", "cartesian", "index", "tupl", "vararg", "int64", "ani", "uint64", "int64", "jl", "type", "morespecif", "none", "type", "match", "child", "parent", "morespecif", "invari", "old", "result", "new", "result", "best", "ntupl", "tupl", "ani", "int", "ntupl", "tupl", "ani", "integ", "tupl", "ptr", "ani", "ntupl", "tupl", "ani", "int64", "tupl", "ptr", "ani", "ntupl", "tupl", "ani", "integ", "note", "that", "~~in", "onli", "one", "case", "does~~ther", "are", "no", "case", "where", "result", "current", "master", "seem", "make", "more", "sens", "me", "than", "version", "here", "think", "there", "'s", "some", "chanc", "that", "onc", "work", "thi", "will", "fix", "some", "ambigu", "similar", "problem"], "title_sim": [0.6199200777958616], "body_sim": [0.7327829091461692], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 56}, {"A_title": "better inference when calling a non-kw method with empty kw", "A_clean_title": ["better", "infer", "when", "call", "non", "kw", "method", "empti", "kw"], "B_title": "Fix type inference problem for eig(SymTridiagonal)", "B_clean_title": ["fix", "type", "infer", "problem", "eig", "symtridiagon", "sym", "tridiagon"], "A_body": "reported by @andreasnoack\n\nis there an open issue about that ?\n", "A_clean_body": ["report", "by", "andreasnoack", "there", "open", "issu", "about", "that"], "B_body": "by changing the catch all kwargs... argument in `eig(StridedMatrix)` to specific keywords and by adding\na fallback eig method without keywords.\n\nAlso changing the formatting of the `eig*` methods for `SymTridiagonal` to make\nthem easier to read.\n", "B_clean_body": ["by", "chang", "catch", "all", "kwarg", "argument", "eig", "stridedmatrix", "stride", "matrix", "specif", "keyword", "by", "ad", "fallback", "eig", "method", "without", "keyword", "also", "chang", "format", "eig*", "method", "symtridiagon", "sym", "tridiagon", "make", "them", "easier", "read"], "title_sim": [0.15908565372842692], "body_sim": [0.11884977029705211], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 0}, {"A_title": "Improve bounds error for ranges", "A_clean_title": ["improv", "bound", "error", "rang"], "B_title": "RFC: Give AbstractArrays smart and performant indexing behaviors for free", "B_clean_title": ["rfc", "give", "abstractarray", "abstract", "array", "smart", "perform", "index", "behavior", "free"], "A_body": "", "A_clean_body": [], "B_body": "~~This is still a work in progress, but I'd like to get some feedback on the architecture and design here before applying this same sort of scheme to `setindex!`.~~\n\nThe basic idea is that the only getindex method defined in base for abstract arrays is `getindex(::AbstractArray, I...)`. And the only methods that an AbstractArray subtype must define are `size` and just one `getindex` method:\n\n``` julia\ngetindex(::T, ::Int) # if linearindexing(T) == LinearFast()\ngetindex(::T, ::Int, ::Int, #=...ndims(A) indices...=#) if LinearSlow()\n```\n\nUnfortunately, it is currently impossible to express the latter method for arbitrary dimensionalities, but in practice it's not a big issue: most LinearSlow() arrays have a fixed dimension.\n\nThis is achieved through dispatch on an internal `_getindex` method, which recomputes the indices such that it can call the canonical `getindex` method that the user must define.  If the user has not defined their canonical method, it will fall back to an error method in `_getindex`.  I use similar scheme for `unsafe_getindex`, with the exception that we can fallback to the safe version if the subtype hasn't defined the canonical unsafe method.  This enables fast vector indexing by checking bounds of the index vectors instead of on each element.  And once `@inbounds` is extensible, AbstractArrays will be able to support it by default.\n\nThe difficulty with all this redirection is that an extra function call can wreck indexing performance, and it can be hard to avoid.  ~~I've had particular difficulty getting good performance with `CartesianIndexes`, and I still lag in performance there by 20x for big arrays.  I think call site inline annotations would be a magic bullet, but there may be other tricks we can use, too.  I've not looked into this very carefully yet, though.~~ (Fixed with a more sensible inlining strategy)\n\nTL/DR:\n\nIn my cursory performance tests [hacked onto Tim's indexing perf suite from his reshape work](https://gist.github.com/mbauman/39bb490ce2bee52417f1) (more tests are needed), I'm close to matching _or outperforming_ master with `Array` with only these definitions:\n\n``` julia\njulia> methods(getindex, (Array, Any...))\n3-element Array{Any,1}:\n getindex(A::Array{T,N},i::Int) at array.jl:304\n getindex{T<:Real}(A::Array{T,N},I::Range{T<:Real}) at array.jl:347 # Needed for bootstrap\n getindex(A::AbstractArray{T,N},I...) at abstractarray.jl:492\n```\n\n(Of course, in places where we're not quite able to close the gap we can always reinstate the specialized methods. This is just a very useful stress-test of both functionality and performance.)\n\ncc: @timholy \n", "B_clean_body": ["~~thi", "still", "work", "progress", "but", "'d", "like", "get", "some", "feedback", "architectur", "design", "here", "befor", "appli", "thi", "same", "sort", "scheme", "setindex", "basic", "idea", "that", "onli", "getindex", "method", "defin", "base", "abstract", "array", "getindex", ":abstractarray", ":abstract", "array", "onli", "method", "that", "abstractarray", "abstract", "array", "subtyp", "must", "defin", "are", "size", "just", "one", "getindex", "method", "julia", "getindex", ":t", ":int", "linearindex", "linearfast", "linear", "fast", "getindex", ":t", ":int", ":int", "ndim", "indic", "linearslow", "linear", "slow", "unfortun", "it", "current", "imposs", "express", "latter", "method", "arbitrari", "dimension", "but", "practic", "it", "'s", "not", "big", "issu", "most", "linearslow", "linear", "slow", "array", "have", "fix", "dimens", "thi", "achiev", "through", "dispatch", "intern", "getindex", "method", "which", "recomput", "indic", "such", "that", "it", "call", "canon", "getindex", "method", "that", "user", "must", "defin", "user", "ha", "not", "defin", "their", "canon", "method", "it", "will", "fall", "back", "error", "method", "getindex", "use", "similar", "scheme", "unsaf", "getindex", "except", "that", "we", "fallback", "safe", "version", "subtyp", "ha", "n't", "defin", "canon", "unsaf", "method", "thi", "enabl", "fast", "vector", "index", "by", "check", "bound", "index", "vector", "instead", "each", "element", "onc", "inbound", "extens", "abstractarray", "abstract", "array", "will", "abl", "support", "it", "by", "default", "difficulti", "all", "thi", "redirect", "that", "extra", "function", "call", "wreck", "index", "perform", "it", "hard", "avoid", "~~i", "'ve", "had", "particular", "difficulti", "get", "good", "perform", "cartesianindex", "cartesian", "index", "still", "lag", "perform", "there", "by", "20x", "big", "array", "think", "call", "site", "inlin", "annot", "would", "magic", "bullet", "but", "there", "may", "other", "trick", "we", "use", "too", "'ve", "not", "look", "into", "thi", "veri", "care", "yet", "though", "fix", "more", "sensibl", "inlin", "strategi", "tl", "dr", "my", "cursori", "perform", "test", "hack", "onto", "tim", "'s", "index", "perf", "suit", "hi", "reshap", "work", "http", "github", "gist", "com", "mbauman", "39bb490ce2bee52417f1", "more", "test", "are", "need", "'m", "close", "match", "or", "outperform", "master", "array", "onli", "these", "definit", "julia", "julia", "method", "getindex", "array", "ani", "element", "array", "any,1", "getindex", ":array", ":int", "at", "array", "jl:304", "getindex", "real", ":array", ":rang", "real", "at", "array", "jl:347", "need", "bootstrap", "getindex", ":abstractarray", ":abstract", "array", "at", "abstractarray", "jl:492", "cours", "place", "where", "we", "'re", "not", "quit", "abl", "close", "gap", "we", "alway", "reinstat", "special", "method", "thi", "just", "veri", "use", "stress", "test", "both", "function", "perform", "cc", "timholi"], "title_sim": [0.07357757914442335], "body_sim": [0.0], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 57}, {"A_title": "Replacement for Base.Test (ready for review)", "A_clean_title": ["replac", "base", "test", "readi", "review"], "B_title": "Don't bail out on test errors by default", "B_clean_title": ["n't", "bail", "out", "test", "error", "by", "default"], "A_body": "The goal of this PR is to make `Base.Test` better than just `assert` with some fancier output. It does so primarily by introducing `@testset`, which lets users bundle tests together and delay throwing an error until the end.\n\nDesign-wise, it primarily needs to be non-breaking for 99.9% uses of the current `Base.Test`, and be simple, minimal, and relatively opinion-free. It is clear there is a large space of possibilities for testing frameworks, but I don't want to go there (personally). My goal is for a incremental improvement over the existing `Base.Test` - if someone wants to pick up the ball and add more features later, they can. A thing that falls outside the scope includes fancier outputs (to, e.g. files).\n\nThis PR is basically https://github.com/IainNZ/BaseTestNext.jl. It is a drop-in replacement for `Base.Test`, and all tests except for those in `test/test.jl` pass without modification.\n\nFeatures for later PRs (probably not by me):\n- Use the special formatting on Travis for expand/collapse (via @simonbyrne)\n- Enable changing the default test set used, which then enables custom output (e.g. JSON, XML)\n- `@test_approx` needs to be either included in the testset world, or even better deprecated in favor of `isapprox` based testing.\n\nSome demo output from BaseTestNext.jl\n\n![Imgur](http://i.imgur.com/aKPwtlb.png)\n", "A_clean_body": ["goal", "thi", "pr", "make", "base", "test", "better", "than", "just", "assert", "some", "fancier", "output", "it", "so", "primarili", "by", "introduc", "testset", "which", "let", "user", "bundl", "test", "togeth", "delay", "throw", "error", "until", "end", "design", "wise", "it", "primarili", "need", "non", "break", "99", "use", "current", "base", "test", "simpl", "minim", "rel", "opinion", "free", "it", "clear", "there", "larg", "space", "possibl", "test", "framework", "but", "n't", "want", "go", "there", "person", "my", "goal", "increment", "improv", "over", "exist", "base", "test", "someon", "want", "pick", "up", "ball", "add", "more", "featur", "later", "they", "thing", "that", "fall", "outsid", "scope", "includ", "fancier", "output", "file", "thi", "pr", "basic", "http", "jl", "github", "com", "iainnz", "basetestnext", "iain", "nz", "base", "test", "next", "it", "drop", "replac", "base", "test", "all", "test", "except", "those", "jl", "test", "test", "pass", "without", "modif", "featur", "later", "pr", "rs", "probabl", "not", "by", "me", "use", "special", "format", "travi", "expand", "collaps", "via", "simonbyrn", "enabl", "chang", "default", "test", "set", "use", "which", "then", "enabl", "custom", "output", "json", "xml", "test", "approx", "need", "either", "includ", "testset", "world", "or", "even", "better", "deprec", "favor", "isapprox", "base", "test", "some", "demo", "output", "basetestnext", "jl", "base", "test", "next", "imgur", "http", "imgur", "png", "com", "akpwtlb", "pwtlb"], "B_body": "I don't always run tests\nBut when I do, I ignore the failures.\n\nSeriously though: when I run all tests locally, it is because I want to know the status of all of them for individual investigation later (e.g. #10394). Tests are slow in general, really slow on Windows, and painfully slow with MCJIT on Windows. Stopping the run due to a (possibly random) failure in the middle of the list is unhelpful because it only tells me about one test failure at a time. (I usually go away when running tests because my 2-core 3320 gets really sluggish). \n\nThis PR makes the test suite continue through errors by default, and adds a check for the environment variable `JL_TESTFAILURE_STOP` for use on the CI systems.\n", "B_clean_body": ["n't", "alway", "run", "test", "but", "when", "ignor", "failur", "serious", "though", "when", "run", "all", "test", "local", "it", "becaus", "want", "know", "statu", "all", "them", "individu", "investig", "later", "10394", "test", "are", "slow", "gener", "realli", "slow", "window", "pain", "slow", "mcjit", "window", "stop", "run", "due", "possibl", "random", "failur", "middl", "list", "unhelp", "becaus", "it", "onli", "tell", "me", "about", "one", "test", "failur", "at", "time", "usual", "go", "away", "when", "run", "test", "becaus", "my", "core", "3320", "get", "realli", "sluggish", "thi", "pr", "make", "test", "suit", "continu", "through", "error", "by", "default", "add", "check", "environ", "variabl", "jl", "testfailur", "stop", "use", "ci", "system"], "title_sim": [0.1683866636228922], "body_sim": [0.44481134718317494], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": -1, "time": 148}, {"A_title": "strip all MD markup when calling docsearch on `Markdown.MD` object", "A_clean_title": ["strip", "all", "md", "markup", "when", "call", "docsearch", "markdown", "md", "object"], "B_title": "Improve apropos searching of markdown", "B_clean_title": ["improv", "apropo", "search", "markdown"], "A_body": "Instead of recursing through the elements inside a `Markdown.MD` object and searching them independently, this PR now strips all markup from the MD and searches all the plain text contents.\n\nThis means that we can now do things like this:\n\n```\njulia> \"\"\"\n       This *would* **not** have worked `before`\n\n       > but now it *does*\n       \"\"\"\n       foo(x, y) = x+y\nfoo (generic function with 1 method)\n\njulia> apropos(\"but now it does\")\nfoo\n\njulia> apropos(r\"would not.+before\")\nfoo\n```\n", "A_clean_body": ["instead", "recurs", "through", "element", "insid", "markdown", "md", "object", "search", "them", "independ", "thi", "pr", "now", "strip", "all", "markup", "md", "search", "all", "plain", "text", "content", "thi", "mean", "that", "we", "now", "thing", "like", "thi", "julia", "thi", "*would*", "**not**", "have", "work", "befor", "but", "now", "it", "*does*", "foo", "x+i", "foo", "gener", "function", "method", "julia", "apropo", "but", "now", "it", "foo", "julia", "apropo", "would", "not", "+befor", "foo"], "B_body": "Search the entire plaintext markdown wholistically (instead of searching each markdown element independently). Before, `docsearch(md\"*foo* bar\", r\"foo.*bar\")` would return false; it now properly returns true.\n\nThis does have significant overhead -- it is about 50x slower than the current implementation -- but it still searches the entire standard library on my wimpy laptop in less than 0.5 seconds after compilation. This does get slightly worse as more packages are imported, but I am not aware of any packages that even come close to defining as many docstrings as there are in the standard library.\n\nAs a bonus, the implementation is much simpler, too.\n", "B_clean_body": ["search", "entir", "plaintext", "markdown", "wholist", "instead", "search", "each", "markdown", "element", "independ", "befor", "docsearch", "md", "*foo*", "bar", "foo", "*bar", "would", "return", "fals", "it", "now", "properli", "return", "true", "thi", "have", "signific", "overhead", "it", "about", "50x", "slower", "than", "current", "implement", "but", "it", "still", "search", "entir", "standard", "librari", "my", "wimpi", "laptop", "less", "than", "second", "after", "compil", "thi", "get", "slightli", "wors", "as", "more", "packag", "are", "import", "but", "am", "not", "awar", "ani", "packag", "that", "even", "come", "close", "defin", "as", "mani", "docstr", "as", "there", "are", "standard", "librari", "as", "bonu", "implement", "much", "simpler", "too"], "title_sim": [0.29659715334276], "body_sim": [0.4396227024491285], "file_list_sim": 1.0, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 23}, {"A_title": "Add missing markdown render methods.", "A_clean_title": ["add", "miss", "markdown", "render", "method"], "B_title": "Move markdown types into their own file.", "B_clean_title": ["move", "markdown", "type", "into", "their", "own", "file"], "A_body": "Markdown plain text rendering was missing for `BlockQuote` and `Link` types.\n", "A_clean_body": ["markdown", "plain", "text", "render", "wa", "miss", "blockquot", "block", "quot", "link", "type"], "B_body": "cc @one-more-minute, I know we [discussed this](https://github.com/JuliaLang/julia/pull/11124#issuecomment-103968053), but after hacking on some other bits, it seems clearer that this is a significant improvement in terms of clearer code / simplicity.... Also, I realised that (after doing this as a proof of concept) it's is going to be difficult to rebase and I don't really want to do it again... so selfishly wanted to punt it as a PR. :)\n\nAll this does is reorder methods so that the rendering utils are available when markdown types are defined, e.g. group all the methods related to Code together.\n\n_This also adds in a couple of missing methods (which I spotted were missing once in individual files)._\n\n~~Edit: I don't think the linux32 travis failure is me!~~\n", "B_clean_body": ["cc", "one", "more", "minut", "know", "we", "discuss", "thi", "http", "github", "com", "julialang", "julia", "pull", "11124", "julia", "lang", "issuecom", "103968053", "but", "after", "hack", "some", "other", "bit", "it", "seem", "clearer", "that", "thi", "signific", "improv", "term", "clearer", "code", "simplic", "also", "realis", "that", "after", "do", "thi", "as", "proof", "concept", "it", "'s", "go", "difficult", "rebas", "n't", "realli", "want", "it", "again", "so", "selfishli", "want", "punt", "it", "as", "pr", "all", "thi", "reorder", "method", "so", "that", "render", "util", "are", "avail", "when", "markdown", "type", "are", "defin", "group", "all", "method", "relat", "code", "togeth", "thi", "also", "add", "coupl", "miss", "method", "which", "spot", "were", "miss", "onc", "individu", "file", "~~edit", "n't", "think", "linux32", "travi", "failur", "me"], "title_sim": [0.4379749957431369], "body_sim": [0.27001575223618435], "file_list_sim": 0.08, "overlap_files_len": 2, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 50}, {"A_title": "Fix libgit2 SSL certificate searching", "A_clean_title": ["fix", "libgit2", "ssl", "certif", "search"], "B_title": "Use mbedtls instead of openssl in libgit2 on Linux", "B_clean_title": ["use", "mbedtl", "instead", "openssl", "libgit2", "linux"], "A_body": "This PR contains two pieces:\n- Makefile fixes to grab OS-provided SSL certificates on Linux during `libgit2` compile time, so that from-source builds and `make binary-dist` builds have a more consistent environment\n- Reordering `libgit2` initialization logic and disabling calling `git_libgit2_opts()` in favor of setting environment variables so as to workaround https://github.com/libgit2/libgit2/pull/3935#issuecomment-253910017.\n\nThis is a somewhat ugly solution to the problem, but until we hear back from that libgit2 PR on the proper way to fix this, this is the best solution I've got.\n", "A_clean_body": ["thi", "pr", "contain", "two", "piec", "makefil", "fix", "grab", "os", "provid", "ssl", "certif", "linux", "dure", "libgit2", "compil", "time", "so", "that", "sourc", "build", "make", "binari", "dist", "build", "have", "more", "consist", "environ", "reorder", "libgit2", "initi", "logic", "disabl", "call", "git", "libgit2", "opt", "favor", "set", "environ", "variabl", "so", "as", "workaround", "http", "github", "com", "libgit2", "libgit2", "pull", "3935", "issuecom", "253910017", "thi", "somewhat", "ugli", "solut", "problem", "but", "until", "we", "hear", "back", "that", "libgit2", "pr", "proper", "way", "fix", "thi", "thi", "best", "solut", "'ve", "got"], "B_body": "This carries the patch from https://github.com/libgit2/libgit2/pull/3462 in order to fix #10763, and close #17471. It seems libgit2 maintainers are reluctant to merge this patch upstream, but maybe we can change their mind eventually. This is a much more maintainable approach than re-implementing a pure Julia TLS stack which is what #17471 was suggesting, and no one is actively working on right now.\n\nWould only be backported to release-0.5 after being tested on master for some time. It fixes an as-yet-unreported issue with our generic Linux binaries where our bundled copy of libgit2 links against libgssapi_krb5.so.2 and a bunch of other things that we don't ship. We've just been getting lucky that most Linux systems happen to have those same libraries installed already. The issue is reproducible if you try to download and run the generic Linux binaries in an Ubuntu docker container that has installed wget and nothing else beyond the base image. Dropping our use of openssl from the build system should fix that, and it's an improvement in several other ways. Since the buildbots run on a very old CentOS, their copy of openssl is old and heavily patched.\n\nAssigning @Keno for review.\n", "B_clean_body": ["thi", "carri", "patch", "http", "github", "com", "libgit2", "libgit2", "pull", "3462", "order", "fix", "10763", "close", "17471", "it", "seem", "libgit2", "maintain", "are", "reluct", "merg", "thi", "patch", "upstream", "but", "mayb", "we", "chang", "their", "mind", "eventu", "thi", "much", "more", "maintain", "approach", "than", "re", "implement", "pure", "julia", "tl", "stack", "which", "what", "17471", "wa", "suggest", "no", "one", "activ", "work", "right", "now", "would", "onli", "backport", "releas", "after", "be", "test", "master", "some", "time", "it", "fix", "as", "yet", "unreport", "issu", "our", "gener", "linux", "binari", "where", "our", "bundl", "copi", "libgit2", "link", "against", "so", "libgssapi", "krb5", "bunch", "other", "thing", "that", "we", "n't", "ship", "we", "'ve", "just", "been", "get", "lucki", "that", "most", "linux", "system", "happen", "have", "those", "same", "librari", "instal", "alreadi", "issu", "reproduc", "you", "tri", "download", "run", "gener", "linux", "binari", "ubuntu", "docker", "contain", "that", "ha", "instal", "wget", "noth", "beyond", "base", "imag", "drop", "our", "use", "openssl", "build", "system", "fix", "that", "it", "'s", "improv", "sever", "other", "way", "sinc", "buildbot", "run", "veri", "old", "cento", "cent", "os", "their", "copi", "openssl", "old", "heavili", "patch", "assign", "keno", "review"], "title_sim": [0.17204788498000623], "body_sim": [0.45571531449000235], "file_list_sim": 0.2857142857142857, "overlap_files_len": 2, "code_sim": [0.04744364135572601, 0.08775011381944284], "location_sim": [0.03143631436314363, 0.651685393258427], "pattern": -1, "time": 20}, {"A_title": "more complete ambiguity detection", "A_clean_title": ["more", "complet", "ambigu", "detect"], "B_title": "Add methods to resolve missing ambiguity in checkbounds", "B_clean_title": ["add", "method", "resolv", "miss", "ambigu", "checkbound"], "A_body": "previously we stopped checking for ambiguities as soon as we reached the definition. this assumed that jl_args_morespecific was transitive, but in actuality it is only a partial sort and we build the typemap assuming no ambiguities, which sometimes made it even less accurate at finding them.\n\n~~note that I needed to partially revert to printing ambiguities or this doesn't make it very far in bootstrap before throwing a method ambiguity error. the RFH (request for help) is to crowd-source resolving these ambiguities (or determining which aren't applicable due to that argument combination not being meaningful).~~\n\nref #16252\nref https://github.com/JuliaLang/julia/pull/16220#discussion_r62260888\n\n~~edit: additionally, due to some recent change, we seem to be unable to detect the ambiguities with Varargs previously computed by https://travis-ci.org/JuliaLang/julia/jobs/126188063~~\nedit2: I mistake in that PR was making it possible to compute that ambiguity (while breaking everything else), it's not a recent regression to be unable to compute that.\n", "A_clean_body": ["previous", "we", "stop", "check", "ambigu", "as", "soon", "as", "we", "reach", "definit", "thi", "assum", "that", "jl", "arg", "morespecif", "wa", "transit", "but", "actual", "it", "onli", "partial", "sort", "we", "build", "typemap", "assum", "no", "ambigu", "which", "sometim", "made", "it", "even", "less", "accur", "at", "find", "them", "~~note", "that", "need", "partial", "revert", "print", "ambigu", "or", "thi", "n't", "make", "it", "veri", "far", "bootstrap", "befor", "throw", "method", "ambigu", "error", "rfh", "request", "help", "crowd", "sourc", "resolv", "these", "ambigu", "or", "determin", "which", "are", "n't", "applic", "due", "that", "argument", "combin", "not", "be", "meaning", "ref", "16252", "ref", "http", "github", "com", "julialang", "julia", "pull", "16220", "julia", "lang", "discuss", "r62260888", "~~edit", "addit", "due", "some", "recent", "chang", "we", "seem", "unabl", "detect", "ambigu", "vararg", "previous", "comput", "by", "http", "travi", "ci", "org", "julialang", "julia", "job", "126188063~~", "julia", "lang", "edit2", "mistak", "that", "pr", "wa", "make", "it", "possibl", "comput", "that", "ambigu", "while", "break", "everyth", "it", "'s", "not", "recent", "regress", "unabl", "comput", "that"], "B_body": "Addresses half of #16252\n", "B_clean_body": ["address", "half", "16252"], "title_sim": [0.07721726161401403], "body_sim": [0.0241275063848959], "file_list_sim": 0.06666666666666667, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 1, "time": 0}, {"A_title": "Make rowvector tests check for specific exception type", "A_clean_title": ["make", "rowvector", "test", "check", "specif", "except", "type"], "B_title": "Added `ConjArray` wrapper type for conjugate array views", "B_clean_title": ["ad", "conjarray", "conj", "array", "wrapper", "type", "conjug", "array", "view"], "A_body": "addresses https://github.com/JuliaLang/julia/pull/19670#discussion_r96156813, cc @andyferris\r\n\r\nand line wrap", "A_clean_body": ["address", "http", "github", "com", "julialang", "julia", "pull", "19670", "julia", "lang", "discuss", "r96156813", "cc", "andyferri", "line", "wrap"], "B_body": "By default, this is used only in conjugation with `RowVector`, so that both `transpose(vec)` and `ctranspose(vec)` both return views.\r\n\r\nHowever, this will pave the way for views for transposed matrices and replacement of `Ac_mul_B`, etc by specialized methods on `*`, simplifying parsing.", "B_clean_body": ["by", "default", "thi", "use", "onli", "conjug", "rowvector", "row", "vector", "so", "that", "both", "transpos", "vec", "ctranspos", "vec", "both", "return", "view", "howev", "thi", "will", "pave", "way", "view", "transpos", "matric", "replac", "ac", "mul", "etc", "by", "special", "method", "simplifi", "pars"], "title_sim": [0.10419450366745633], "body_sim": [0.007926365510242677], "file_list_sim": 0.2, "overlap_files_len": 2, "code_sim": [0.0, 0.0], "location_sim": [0.36767676767676766, 0.52], "pattern": 0, "time": 4}, {"A_title": "new doc city", "A_clean_title": ["new", "doc", "citi"], "B_title": "WIP: Doc Transition", "B_clean_title": ["wip", "doc", "transit"], "A_body": "The epic transition from old doc system to new.\n", "A_clean_body": ["epic", "transit", "old", "doc", "system", "new"], "B_body": "This moves our 1503 docstrings from helpdb.jl into the new doc system. Docstrings are now stored in `base/docs/helpdb.jl` (soon to be scattered around base) and we have a hackish script which dumps those docstrings into the RST manual (at least until we move to markdown).\n\nCaveats:\n- Undocumented globals: `[\"ans\", \"CPU_CORES\", \"JULIA_HOME\", \"STDOUT\", \"STDERR\", \"STDIN\"]` \u2013\u00a0need to implement docs for variable bindings to fix this.\n- helpdb didn't support multimethods well, so some functions and docstrings have duplicated entries.\n\nOn the whole though we should only have lost on the order of tens of docstrings, as opposed to thousands.\n", "B_clean_body": ["thi", "move", "our", "1503", "docstr", "helpdb", "jl", "into", "new", "doc", "system", "docstr", "are", "now", "store", "jl", "base", "doc", "helpdb", "soon", "scatter", "around", "base", "we", "have", "hackish", "script", "which", "dump", "those", "docstr", "into", "rst", "manual", "at", "least", "until", "we", "move", "markdown", "caveat", "undocu", "global", "an", "cpu", "core", "julia", "home", "stdout", "stderr", "stdin", "need", "implement", "doc", "variabl", "bind", "fix", "thi", "helpdb", "did", "n't", "support", "multimethod", "well", "so", "some", "function", "docstr", "have", "duplic", "entri", "whole", "though", "we", "onli", "have", "lost", "order", "ten", "docstr", "as", "oppos", "thousand"], "title_sim": [0.5051329481568921], "body_sim": [0.2631648545959408], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 4}, {"A_title": "Do codegen in control flow order", "A_clean_title": ["codegen", "control", "flow", "order"], "B_title": "turn codegen into a C++ class", "B_clean_title": ["turn", "codegen", "into", "c++", "class"], "A_body": "- Fix codegen of `SSAValue` whose assignment appears later than the user\n  in syntactic order due to backward branches.\n  \n    See the added test.\n- Disallow more expression types in value position\n- Use improved debug info metadata in coverage and allocation tracking too\n\nMarked as WIP since one of the boundscheck test is still failing, probably because some of the inbounds handling are slightly different. Will also need to run benchmarks after that is fixed.\n", "A_clean_body": ["fix", "codegen", "ssavalu", "ssa", "valu", "whose", "assign", "appear", "later", "than", "user", "syntact", "order", "due", "backward", "branch", "see", "ad", "test", "disallow", "more", "express", "type", "valu", "posit", "use", "improv", "debug", "info", "metadata", "coverag", "alloc", "track", "too", "mark", "as", "wip", "sinc", "one", "boundscheck", "test", "still", "fail", "probabl", "becaus", "some", "inbound", "handl", "are", "slightli", "differ", "will", "also", "need", "run", "benchmark", "after", "that", "fix"], "B_body": "this lets us stop passing around `ctx`, while not making any functional changes (yet)\n", "B_clean_body": ["thi", "let", "us", "stop", "pass", "around", "ctx", "while", "not", "make", "ani", "function", "chang", "yet"], "title_sim": [0.24501336565644605], "body_sim": [0.09517552242474239], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 2}, {"A_title": "Immediately expand JULIAHOME in Makefile", "A_clean_title": ["immedi", "expand", "juliahom", "makefil"], "B_title": "Fix embedding example, simplify Makefile, and test it", "B_clean_title": ["fix", "embed", "exampl", "simplifi", "makefil", "test", "it"], "A_body": "This fixes part one of https://github.com/JuliaLang/julia/issues/21137\r\n\r\nThe size of my patches is starting to get pretty small.  Next up: replace a single character with the smallest possible hamming distance to truly attain the smallest possible diff.", "A_clean_body": ["thi", "fix", "part", "one", "http", "github", "com", "julialang", "julia", "issu", "21137", "julia", "lang", "size", "my", "patch", "start", "get", "pretti", "small", "next", "up", "replac", "singl", "charact", "smallest", "possibl", "ham", "distanc", "truli", "attain", "smallest", "possibl", "diff"], "B_body": "- get rid of makefile cruft\r\n- build in-place instead of putting in usr/bin\r\n- use julia-config for flags, as documented in manual\r\n\r\n(related: #18421)", "B_clean_body": ["get", "rid", "makefil", "cruft", "build", "place", "instead", "put", "usr", "bin", "use", "julia", "config", "flag", "as", "document", "manual", "relat", "18421"], "title_sim": [0.5350830177855127], "body_sim": [0.10178373356694408], "file_list_sim": 0.08333333333333333, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.11688311688311688, 1.0], "pattern": -1, "time": 41}, {"A_title": "Add missing return argument for jl_atexit_hook.", "A_clean_title": ["add", "miss", "return", "argument", "jl", "atexit", "hook"], "B_title": "fix embedding docs of jl_atexit_hook", "B_clean_title": ["fix", "embed", "doc", "jl", "atexit", "hook"], "A_body": "", "A_clean_body": [], "B_body": "It seems that this now takes a return value parameter.\n", "B_clean_body": ["it", "seem", "that", "thi", "now", "take", "return", "valu", "paramet"], "title_sim": [0.29416154116309595], "body_sim": [0.0], "file_list_sim": 0.5, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.5, 0.6666666666666666], "pattern": 0, "time": 4}, {"A_title": "make win32 julia-debug build work again", "A_clean_title": ["make", "win32", "julia", "debug", "build", "work", "again"], "B_title": "maybe fix julia-debug on windows", "B_clean_title": ["mayb", "fix", "julia", "debug", "window"], "A_body": "this makes two copies of sys.dll, linked against both libjulia and libjulia-debug, so that the user can pick the right one. loading the wrong one will probably cause a segfault pretty quickly.\n\nbreadcrumb: these copies of sys.dll were built independently, so the cache search path in #8745 will also need to be updated to be split based on some function of the debugbuild flag, sys.so name/location, or the Main.uid value.\n", "A_clean_body": ["thi", "make", "two", "copi", "sy", "dll", "link", "against", "both", "libjulia", "libjulia", "debug", "so", "that", "user", "pick", "right", "one", "load", "wrong", "one", "will", "probabl", "caus", "segfault", "pretti", "quickli", "breadcrumb", "these", "copi", "sy", "dll", "were", "built", "independ", "so", "cach", "search", "path", "8745", "will", "also", "need", "updat", "split", "base", "some", "function", "debugbuild", "flag", "sy", "so", "name", "locat", "or", "main", "uid", "valu"], "B_body": "... by loading sys.dll but ignoring the code in it. cc @tkelman \n\nI haven't tried this yet on windows.\n", "B_clean_body": ["by", "load", "sy", "dll", "but", "ignor", "code", "it", "cc", "tkelman", "have", "n't", "tri", "thi", "yet", "window"], "title_sim": [0.3002269541091014], "body_sim": [0.26959090108575445], "file_list_sim": 0.1111111111111111, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.10849056603773585, 0.7931034482758621], "pattern": 0, "time": 0}, {"A_title": "A few small miscellaneous tests", "A_clean_title": ["few", "small", "miscellan", "test"], "B_title": "WIP: dates-io coverage", "B_clean_title": ["wip", "date", "io", "coverag"], "A_body": "For `Dates` and a last missing one for `Char`.\n", "A_clean_body": ["date", "last", "miss", "one", "char"], "B_body": "Test show representation of Date/DateTime.\n\nRefs: \n- https://coveralls.io/builds/2869755/source?filename=base%2Fdates%2Fio.jl#L16\n- https://coveralls.io/builds/2869755/source?filename=base%2Fdates%2Fio.jl#L24\n\n[av skip]\n", "B_clean_body": ["test", "show", "represent", "date", "datetim", "date", "time", "ref", "http", "coveral", "io", "build", "2869755", "sourc", "filename=bas", "2fdate", "2fio", "jl", "l16", "http", "coveral", "io", "build", "2869755", "sourc", "filename=bas", "2fdate", "2fio", "jl", "l24", "av", "skip"], "title_sim": [0.04608854518805701], "body_sim": [0.2967676613895293], "file_list_sim": 0.2, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.4927536231884058, 1.0], "pattern": 0, "time": 355}, {"A_title": "Fixed the algorithm for powers of a matrix.", "A_clean_title": ["fix", "algorithm", "power", "matrix"], "B_title": "WIP: Improve accuracy of ^ for ill-conditioned matrices", "B_clean_title": ["wip", "improv", "accuraci", "ill", "condit", "matric"], "A_body": "Fixed #21143 \r\n\r\nI did a few small bug-fixes and also changed the [^(A::AbstractMatrix, p::Integer)](https://github.com/iamnapo/julia/blob/anj/powm/base/linalg/dense.jl#L314) algorithm a bit to make use of [powm(A0::UpperTriangular{T}, p::Real)](https://github.com/iamnapo/julia/blob/anj/powm/base/linalg/triangular.jl#L1671).", "A_clean_body": ["fix", "21143", "did", "few", "small", "bug", "fix", "also", "chang", ":abstractmatrix", ":abstract", "matrix", ":integ", "http", "jl", "github", "com", "iamnapo", "julia", "blob", "anj", "powm", "base", "linalg", "dens", "l314", "algorithm", "bit", "make", "use", "powm", "a0", ":uppertriangular", ":upper", "triangular", ":real", "http", "jl", "github", "com", "iamnapo", "julia", "blob", "anj", "powm", "base", "linalg", "triangular", "l1671"], "B_body": "Add the algorithm for `A^t` from Higham and Lin, 2013. See #5840.\n\nI split the old version of `logm` into several functions to reuse some of the code.\n", "B_clean_body": ["add", "algorithm", "a^t", "higham", "lin", "2013", "see", "5840", "split", "old", "version", "logm", "into", "sever", "function", "reus", "some", "code"], "title_sim": [-0.009357709227449374], "body_sim": [0.05419928953760113], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": -1, "time": 593}, {"A_title": "update test/perf README (fix #19853)", "A_clean_title": ["updat", "test", "perf", "readm", "fix", "19853"], "B_title": "Docs: Fixes #19853", "B_clean_title": ["doc", "fix", "19853"], "A_body": "", "A_clean_body": [], "B_body": "Removed dead links and replaced the abandoned benchmark package.", "B_clean_body": ["remov", "dead", "link", "replac", "abandon", "benchmark", "packag"], "title_sim": [0.2005807947076852], "body_sim": [0.0], "file_list_sim": 1.0, "overlap_files_len": 1, "code_sim": [0.45268295895313604, 0.45268295895313604], "location_sim": [0.7971014492753623, 0.7971014492753623], "pattern": 1, "time": 0}, {"A_title": "avoid DomainError in @time", "A_clean_title": ["avoid", "domainerror", "domain", "error", "time"], "B_title": "Include `deferred_alloc` in total allocation count", "B_clean_title": ["includ", "defer", "alloc", "total", "alloc", "count"], "A_body": "when bytes == 0 and allocs != 0\n\n```\n 1.750165 secondsERROR: LoadError: DomainError:\n in nan_dom_err at ./math.jl:257 [inlined]\n in log(::Float64) at ./math.jl:263\n in prettyprint_getunits(::Int64, ::Int64, ::Int64) at ./util.jl:123\n in time_print(::UInt64, ::Int64, ::Int64, ::Int64) at ./util.jl:139\n in include_from_node1(::String) at ./loading.jl:532\n in include(::String) at ./sysimg.jl:14\n```\n", "A_clean_body": ["when", "byte", "alloc", "750165", "secondserror", "second", "error", "loaderror", "load", "error", "domainerror", "domain", "error", "nan", "dom", "err", "at", "jl:257", "math", "inlin", "log", ":float64", "at", "jl:263", "math", "prettyprint", "getunit", ":int64", ":int64", ":int64", "at", "jl:123", "util", "time", "print", ":uint64", ":u", "int64", ":int64", ":int64", ":int64", "at", "jl:139", "util", "includ", "node1", ":string", "at", "jl:532", "load", "includ", ":string", "at", "jl:14", "sysimg"], "B_body": "This was caused by https://github.com/JuliaLang/julia/pull/17229, which should have been obvious since the issue was reported 2 days after the PR was merged.....\n\nFix #17255\n", "B_clean_body": ["thi", "wa", "caus", "by", "http", "github", "com", "julialang", "julia", "pull", "17229", "julia", "lang", "which", "have", "been", "obviou", "sinc", "issu", "wa", "report", "day", "after", "pr", "wa", "merg", "fix", "17255"], "title_sim": [0.07236055947331442], "body_sim": [0.013774878057077396], "file_list_sim": 0.3333333333333333, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": -1, "time": 7}, {"A_title": "Fix so windows opens the default editor when `@edit` is used", "A_clean_title": ["fix", "so", "window", "open", "default", "editor", "when", "edit", "use"], "B_title": "Improve windows shell mode; fix edit() function for windows", "B_clean_title": ["improv", "window", "shell", "mode", "fix", "edit", "function", "window"], "A_body": "This fixes so windows can open source files with `@edit` macro using the default editor and I have added a notice to the user where to find the function when no line number info is sent to the editor.\n", "A_clean_body": ["thi", "fix", "so", "window", "open", "sourc", "file", "edit", "macro", "default", "editor", "have", "ad", "notic", "user", "where", "find", "function", "when", "no", "line", "number", "info", "sent", "editor"], "B_body": "Prepend 'cmd /c' to edit function `start` command to allow files to be opened properly on windows. Also prepend it to repl_cmd commands to better emulate shell mode for windows. Fixes #7107.\n", "B_clean_body": ["prepend", "'cmd", "edit", "function", "start", "command", "allow", "file", "open", "properli", "window", "also", "prepend", "it", "repl", "cmd", "command", "better", "emul", "shell", "mode", "window", "fix", "7107"], "title_sim": [0.43128444842013114], "body_sim": [0.37448574512361665], "file_list_sim": 0.3333333333333333, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.7454545454545455, 1.0], "pattern": 0, "time": 136}, {"A_title": "Add count(itr) to count true elements", "A_clean_title": ["add", "count", "itr", "count", "true", "element"], "B_title": "make count(f,itr) count the number of nonzero; countnz(itr) -> count(itr)", "B_clean_title": ["make", "count", "itr", "count", "number", "nonzero", "countnz", "itr", "count", "itr"], "A_body": "Fix https://github.com/JuliaLang/julia/issues/20403.", "A_clean_body": ["fix", "http", "github", "com", "julialang", "julia", "issu", "20403", "julia", "lang"], "B_body": "Closes #20403, #20404.", "B_clean_body": ["close", "20403", "20404"], "title_sim": [0.8341883022763112], "body_sim": [0.021362327294577568], "file_list_sim": 0.047619047619047616, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [0.1346153846153846, 0.8888888888888888], "pattern": 1, "time": 0}, {"A_title": "Path with space completion fix for REPL", "A_clean_title": ["path", "space", "complet", "fix", "repl"], "B_title": "Improve windows shell mode; fix edit() function for windows", "B_clean_title": ["improv", "window", "shell", "mode", "fix", "edit", "function", "window"], "A_body": "This fixes completion for paths with spaces in both shell mode and julia mode ex:\n\n``` julia\nshell>cd C:\\\\Program\\ Files\\ <tab>\nshell>cd C:\\\\Program\\ Files\\ (x86)\\\\\njulia>cd(\"C:\\\\Program\\ Files\\ <tab>\njulia>cd (\"C:\\\\Program\\ Files\\ (x86)\\\\\n```\n\nThe main changes is in the `completions` that is used when completing in julia mode. The changes to get it working in shell mode is only 5 lines. If any of you have time to look at it @tkelman, @lucasb-eyer it would be greatly appreciated.\n\n@StefanKarpinski could you approve the changes I made in the `shell_parse`? The main reason for the change is when a string is parsed to the `shell_parse` function like: `\"C:\\\\Progams\\\\ \"` this would throw an error before due to the ending space is removed and then the string has a dangling `\\`. To prevent it from removing the space I use the keyword argument like: `Base.shell_parse(string[r], true, strip_r=!endswith(string[r], \"\\\\ \")` and then it do not trim the space away when the string ends on `\"\\\\ \"`.\n", "A_clean_body": ["thi", "fix", "complet", "path", "space", "both", "shell", "mode", "julia", "mode", "ex", "julia", "shell", "cd", "program", "file", "tab", "shell", "cd", "program", "file", "x86", "julia", "cd", "program", "file", "tab", "julia", "cd", "program", "file", "x86", "main", "chang", "complet", "that", "use", "when", "complet", "julia", "mode", "chang", "get", "it", "work", "shell", "mode", "onli", "line", "ani", "you", "have", "time", "look", "at", "it", "tkelman", "lucasb", "eyer", "it", "would", "greatli", "appreci", "stefankarpinski", "stefan", "karpinski", "could", "you", "approv", "chang", "made", "shell", "pars", "main", "reason", "chang", "when", "string", "pars", "shell", "pars", "function", "like", "progam", "thi", "would", "throw", "error", "befor", "due", "end", "space", "remov", "then", "string", "ha", "dangl", "prevent", "it", "remov", "space", "use", "keyword", "argument", "like", "base", "shell", "pars", "string", "true", "strip", "r=", "endswith", "string", "then", "it", "not", "trim", "space", "away", "when", "string", "end"], "B_body": "Prepend 'cmd /c' to edit function `start` command to allow files to be opened properly on windows. Also prepend it to repl_cmd commands to better emulate shell mode for windows. Fixes #7107.\n", "B_clean_body": ["prepend", "'cmd", "edit", "function", "start", "command", "allow", "file", "open", "properli", "window", "also", "prepend", "it", "repl", "cmd", "command", "better", "emul", "shell", "mode", "window", "fix", "7107"], "title_sim": [0.08172835279972093], "body_sim": [0.5267069598449786], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 146}, {"A_title": "RFC: Give AbstractArrays smart and performant indexing behaviors for free", "A_clean_title": ["rfc", "give", "abstractarray", "abstract", "array", "smart", "perform", "index", "behavior", "free"], "B_title": "Improve BoundsError reporting for AbstractArrays", "B_clean_title": ["improv", "boundserror", "bound", "error", "report", "abstractarray", "abstract", "array"], "A_body": "~~This is still a work in progress, but I'd like to get some feedback on the architecture and design here before applying this same sort of scheme to `setindex!`.~~\n\nThe basic idea is that the only getindex method defined in base for abstract arrays is `getindex(::AbstractArray, I...)`. And the only methods that an AbstractArray subtype must define are `size` and just one `getindex` method:\n\n``` julia\ngetindex(::T, ::Int) # if linearindexing(T) == LinearFast()\ngetindex(::T, ::Int, ::Int, #=...ndims(A) indices...=#) if LinearSlow()\n```\n\nUnfortunately, it is currently impossible to express the latter method for arbitrary dimensionalities, but in practice it's not a big issue: most LinearSlow() arrays have a fixed dimension.\n\nThis is achieved through dispatch on an internal `_getindex` method, which recomputes the indices such that it can call the canonical `getindex` method that the user must define.  If the user has not defined their canonical method, it will fall back to an error method in `_getindex`.  I use similar scheme for `unsafe_getindex`, with the exception that we can fallback to the safe version if the subtype hasn't defined the canonical unsafe method.  This enables fast vector indexing by checking bounds of the index vectors instead of on each element.  And once `@inbounds` is extensible, AbstractArrays will be able to support it by default.\n\nThe difficulty with all this redirection is that an extra function call can wreck indexing performance, and it can be hard to avoid.  ~~I've had particular difficulty getting good performance with `CartesianIndexes`, and I still lag in performance there by 20x for big arrays.  I think call site inline annotations would be a magic bullet, but there may be other tricks we can use, too.  I've not looked into this very carefully yet, though.~~ (Fixed with a more sensible inlining strategy)\n\nTL/DR:\n\nIn my cursory performance tests [hacked onto Tim's indexing perf suite from his reshape work](https://gist.github.com/mbauman/39bb490ce2bee52417f1) (more tests are needed), I'm close to matching _or outperforming_ master with `Array` with only these definitions:\n\n``` julia\njulia> methods(getindex, (Array, Any...))\n3-element Array{Any,1}:\n getindex(A::Array{T,N},i::Int) at array.jl:304\n getindex{T<:Real}(A::Array{T,N},I::Range{T<:Real}) at array.jl:347 # Needed for bootstrap\n getindex(A::AbstractArray{T,N},I...) at abstractarray.jl:492\n```\n\n(Of course, in places where we're not quite able to close the gap we can always reinstate the specialized methods. This is just a very useful stress-test of both functionality and performance.)\n\ncc: @timholy \n", "A_clean_body": ["~~thi", "still", "work", "progress", "but", "'d", "like", "get", "some", "feedback", "architectur", "design", "here", "befor", "appli", "thi", "same", "sort", "scheme", "setindex", "basic", "idea", "that", "onli", "getindex", "method", "defin", "base", "abstract", "array", "getindex", ":abstractarray", ":abstract", "array", "onli", "method", "that", "abstractarray", "abstract", "array", "subtyp", "must", "defin", "are", "size", "just", "one", "getindex", "method", "julia", "getindex", ":t", ":int", "linearindex", "linearfast", "linear", "fast", "getindex", ":t", ":int", ":int", "ndim", "indic", "linearslow", "linear", "slow", "unfortun", "it", "current", "imposs", "express", "latter", "method", "arbitrari", "dimension", "but", "practic", "it", "'s", "not", "big", "issu", "most", "linearslow", "linear", "slow", "array", "have", "fix", "dimens", "thi", "achiev", "through", "dispatch", "intern", "getindex", "method", "which", "recomput", "indic", "such", "that", "it", "call", "canon", "getindex", "method", "that", "user", "must", "defin", "user", "ha", "not", "defin", "their", "canon", "method", "it", "will", "fall", "back", "error", "method", "getindex", "use", "similar", "scheme", "unsaf", "getindex", "except", "that", "we", "fallback", "safe", "version", "subtyp", "ha", "n't", "defin", "canon", "unsaf", "method", "thi", "enabl", "fast", "vector", "index", "by", "check", "bound", "index", "vector", "instead", "each", "element", "onc", "inbound", "extens", "abstractarray", "abstract", "array", "will", "abl", "support", "it", "by", "default", "difficulti", "all", "thi", "redirect", "that", "extra", "function", "call", "wreck", "index", "perform", "it", "hard", "avoid", "~~i", "'ve", "had", "particular", "difficulti", "get", "good", "perform", "cartesianindex", "cartesian", "index", "still", "lag", "perform", "there", "by", "20x", "big", "array", "think", "call", "site", "inlin", "annot", "would", "magic", "bullet", "but", "there", "may", "other", "trick", "we", "use", "too", "'ve", "not", "look", "into", "thi", "veri", "care", "yet", "though", "fix", "more", "sensibl", "inlin", "strategi", "tl", "dr", "my", "cursori", "perform", "test", "hack", "onto", "tim", "'s", "index", "perf", "suit", "hi", "reshap", "work", "http", "github", "gist", "com", "mbauman", "39bb490ce2bee52417f1", "more", "test", "are", "need", "'m", "close", "match", "or", "outperform", "master", "array", "onli", "these", "definit", "julia", "julia", "method", "getindex", "array", "ani", "element", "array", "any,1", "getindex", ":array", ":int", "at", "array", "jl:304", "getindex", "real", ":array", ":rang", "real", "at", "array", "jl:347", "need", "bootstrap", "getindex", ":abstractarray", ":abstract", "array", "at", "abstractarray", "jl:492", "cours", "place", "where", "we", "'re", "not", "quit", "abl", "close", "gap", "we", "alway", "reinstat", "special", "method", "thi", "just", "veri", "use", "stress", "test", "both", "function", "perform", "cc", "timholi"], "B_body": "This uses the new interface of `BoundsError` in the `checkbounds` functions, which is used by AbstractArrays (including Arrays in some cases). In order to do that, I had to split the external (exported and documented) version of `checkbounds` and the internal one, which used a different - undocumented - interface. I called `_checkbounds` the latter, but suggestions for better names are indeed welcome, even if it's just and internal function.\n\nUsing BitArrays as an example, here is a before/after:\n\nBefore:\n\n```\njulia-0.4> b = bitrand(3);\n\njulia-0.4> b[4] = true # does not call checkbounds\nERROR: BoundsError: attempt to access 3-element BitArray{1}:\n  true\n  true\n false\n  at index [4]\n\njulia-0.4> b[4] = 1\nERROR: BoundsError\n in checkbounds at abstractarray.jl:78\n in checkbounds at abstractarray.jl:110\n in setindex! at multidimensional.jl:629\n```\n\nAfter:\n\n```\njulia-0.4> b = bitrand(3);\n\njulia-0.4> b[4] = true # does not call checkbounds\nERROR: BoundsError: attempt to access 3-element BitArray{1}:\n  true\n  true\n false\n  at index [4]\n\njulia-0.4> b[4] = 1\nERROR: BoundsError: attempt to access 3-element BitArray{1}:\n  true\n  true\n false\n  at index [4]\n in _checkbounds at abstractarray.jl:78\n in checkbounds at abstractarray.jl:110\n in setindex! at multidimensional.jl:629\n```\n\nI tried to avoid extra allocations etc, but I'm submitting as a PR for review just to confirm that there should be no performance issues (cc @vtjnash which did the new BoundsError interface).\n\nOut of necessity, the reporting is also not particularly precise in more convoluted cases, e.g.:\n\n```\njulia-0.4> a = rand(2,3,2);\n\njulia-0.4> a[2,bitrand(4),2]\nERROR: BoundsError: attempt to access 2x3x2 Array{Float64,3}:\n[:, :, 1] =\n 0.0514813   0.573538  0.150317\n 0.00485321  0.118724  0.435752\n\n[:, :, 2] =\n 0.0525793  0.731588  0.813656\n 0.0234425  0.894198  0.977163\n  at index [2,Bool[true,true,false,false],2]\n in _checkbounds at abstractarray.jl:80\n in checkbounds at abstractarray.jl:108\n in getindex at multidimensional.jl:188\n```\n\nwhere the whole indexing expression is reported; it's still much better then before though.\n\nIf this is OK I'll proceed improving the error reporting in other areas as well (e.g. Strings).\n", "B_clean_body": ["thi", "use", "new", "interfac", "boundserror", "bound", "error", "checkbound", "function", "which", "use", "by", "abstractarray", "abstract", "array", "includ", "array", "some", "case", "order", "that", "had", "split", "extern", "export", "document", "version", "checkbound", "intern", "one", "which", "use", "differ", "undocu", "interfac", "call", "checkbound", "latter", "but", "suggest", "better", "name", "are", "inde", "welcom", "even", "it", "'s", "just", "intern", "function", "bitarray", "bit", "array", "as", "exampl", "here", "befor", "after", "befor", "julia", "bitrand", "julia", "true", "not", "call", "checkbound", "error", "boundserror", "bound", "error", "attempt", "access", "element", "bitarray", "bit", "array", "true", "true", "fals", "at", "index", "julia", "error", "boundserror", "bound", "error", "checkbound", "at", "abstractarray", "jl:78", "checkbound", "at", "abstractarray", "jl:110", "setindex", "at", "multidimension", "jl:629", "after", "julia", "bitrand", "julia", "true", "not", "call", "checkbound", "error", "boundserror", "bound", "error", "attempt", "access", "element", "bitarray", "bit", "array", "true", "true", "fals", "at", "index", "julia", "error", "boundserror", "bound", "error", "attempt", "access", "element", "bitarray", "bit", "array", "true", "true", "fals", "at", "index", "checkbound", "at", "abstractarray", "jl:78", "checkbound", "at", "abstractarray", "jl:110", "setindex", "at", "multidimension", "jl:629", "tri", "avoid", "extra", "alloc", "etc", "but", "'m", "submit", "as", "pr", "review", "just", "confirm", "that", "there", "no", "perform", "issu", "cc", "vtjnash", "which", "did", "new", "boundserror", "bound", "error", "interfac", "out", "necess", "report", "also", "not", "particularli", "precis", "more", "convolut", "case", "julia", "rand", "2,3,2", "julia", "bitrand", ",2", "error", "boundserror", "bound", "error", "attempt", "access", "2x3x2", "array", "float64,3", "0514813", "573538", "150317", "00485321", "118724", "435752", "0525793", "731588", "813656", "0234425", "894198", "977163", "at", "index", "bool", "true", "true", "fals", "fals", ",2", "checkbound", "at", "abstractarray", "jl:80", "checkbound", "at", "abstractarray", "jl:108", "getindex", "at", "multidimension", "jl:188", "where", "whole", "index", "express", "report", "it", "'s", "still", "much", "better", "then", "befor", "though", "thi", "ok", "'ll", "proceed", "improv", "error", "report", "other", "area", "as", "well", "string"], "title_sim": [0.44481447385564926], "body_sim": [0.4094954684182756], "file_list_sim": 0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 69}, {"A_title": "Few tests for DevNull properties", "A_clean_title": ["few", "test", "devnul", "dev", "null", "properti"], "B_title": "fix the read and write methods of DevNull", "B_clean_title": ["fix", "read", "write", "method", "devnul", "dev", "null"], "A_body": "I wasn't sure if `test/misc.jl` was the right place for these. I can move them if there's a better file for them to go in.\n", "A_clean_body": ["wa", "n't", "sure", "jl", "test", "misc", "wa", "right", "place", "these", "move", "them", "there", "'s", "better", "file", "them", "go"], "B_body": "This patch fixes the IO-related behaviors of `DevNull`.\n\nIn the current revision, `write(DevNull, 0x00)` is not callable:\n\n``` julia\n~/v/julia (master|\u271a1\u2026) $ julia-dev\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"?help\" for help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.5.0-dev+963 (2015-10-25 05:30 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Commit 5d7c0ad* (0 days old master)\n|__/                   |  x86_64-apple-darwin14.5.0\n\njulia> write(DevNull, 0x00)\nERROR: Base.DevNullStream does not support byte I/O\n [inlined code] from error.jl:22\n in write at io.jl:338\n```\n\nAnd `read(DevNull, UInt8)` throws an incorrect exception due to a typo (`EOFErorr`).\nSo, I fixed these problems and added tests in `test/io.jl`, which is a newly created file for these tests since I couldn't find a suitable place to put them.\n", "B_clean_body": ["thi", "patch", "fix", "io", "relat", "behavior", "devnul", "dev", "null", "current", "revis", "write", "devnul", "dev", "null", "0x00", "not", "callabl", "julia", "julia", "master|\u271a1\u2026", "julia", "dev", "fresh", "approach", "technic", "comput", "document", "http", "julialang", "org", "doc", "type", "help", "help", "version", "dev+963", "2015", "10", "25", "05:30", "utc", "commit", "5d7c0ad*", "day", "old", "master", "appl", "x86", "64", "darwin14", "julia", "write", "devnul", "dev", "null", "0x00", "error", "base", "devnullstream", "dev", "null", "stream", "not", "support", "byte", "inlin", "code", "error", "jl:22", "write", "at", "io", "jl:338", "read", "devnul", "dev", "null", "uint8", "int8", "throw", "incorrect", "except", "due", "typo", "eoferorr", "eof", "erorr", "so", "fix", "these", "problem", "ad", "test", "jl", "test", "io", "which", "newli", "creat", "file", "these", "test", "sinc", "could", "n't", "find", "suitabl", "place", "put", "them"], "title_sim": [0.0842380995063259], "body_sim": [0.24454148119980446], "file_list_sim": 0.0, "overlap_files_len": 0, "code_sim": [0.0, 0.0], "location_sim": [0.0, 0.0], "pattern": 0, "time": 25}, {"A_title": "Fix example in documentation", "A_clean_title": ["fix", "exampl", "document"], "B_title": "Fix typo in variables-and-scoping.rst", "B_clean_title": ["fix", "typo", "variabl", "scope", "rst"], "A_body": "There was a wrong output for the example of scoping of for-loops variables.\n", "A_clean_body": ["there", "wa", "wrong", "output", "exampl", "scope", "loop", "variabl"], "B_body": "Fixed 11 to 12 in output of soft local scope example. \n", "B_clean_body": ["fix", "11", "12", "output", "soft", "local", "scope", "exampl"], "title_sim": [0.13325308019704538], "body_sim": [0.4746773546947459], "file_list_sim": 1.0, "overlap_files_len": 1, "code_sim": [0.0, 0.0], "location_sim": [1.0, 1.0], "pattern": 0, "time": 2}, {"A_title": "fix embedding example, continued", "A_clean_title": ["fix", "embed", "exampl", "continu"], "B_title": "Build, test, and install embedding example.", "B_clean_title": ["build", "test", "instal", "embed", "exampl"], "A_body": "This is a rebased version of #20535, plus the changes I wanted. ~~However the example program crashes on startup for me; have not figured out the problem yet.~~", "A_clean_body": ["thi", "rebas", "version", "20535", "plu", "chang", "want", "~~howev", "exampl", "program", "crash", "startup", "me", "have", "not", "figur", "out", "problem", "yet"], "B_body": "Addresses #8757. Should catch basic regressions in the embedding example.\n", "B_clean_body": ["address", "8757", "catch", "basic", "regress", "embed", "exampl"], "title_sim": [0.28768263142117306], "body_sim": [0.20137643380542158], "file_list_sim": 0.09090909090909091, "overlap_files_len": 2, "code_sim": [0.0, 0.0], "location_sim": [0.16082474226804125, 0.582089552238806], "pattern": -1, "time": 191}, {"A_title": "Bump openlibm/specfun versions to get properly versioned shlibs for them", "A_clean_title": ["bump", "openlibm", "specfun", "version", "get", "properli", "version", "shlib", "them"], "B_title": "Bump to openlibm v0.5 and openspecfun v0.5", "B_clean_title": ["bump", "openlibm", "v0", "openspecfun", "v0"], "A_body": "Also move openspecfun git branch to `v0.5.1` as `master` is just a branch and is less desirable.\n", "A_clean_body": ["also", "move", "openspecfun", "git", "branch", "v0", "as", "master", "just", "branch", "less", "desir"], "B_body": "Bump openlibm and openspecfun versions. This is primarily to run all the tests in CI, and upstream versions will be tagged if everything passes. This PR will then be updated to then use the released upstream versions.\n", "B_clean_body": ["bump", "openlibm", "openspecfun", "version", "thi", "primarili", "run", "all", "test", "ci", "upstream", "version", "will", "tag", "everyth", "pass", "thi", "pr", "will", "then", "updat", "then", "use", "releas", "upstream", "version"], "title_sim": [0.5408293329575631], "body_sim": [0.09565761321240282], "file_list_sim": 0.42857142857142855, "overlap_files_len": 6, "code_sim": [0.0, 0.0], "location_sim": [0.5, 1.0], "pattern": -1, "time": 84}, {"A_title": "`rand` sampling from an array accepts an optional rng", "A_clean_title": ["rand", "sampl", "array", "accept", "option", "rng"], "B_title": "WIP: Add methods: optional RNG argument to rand([rng], Array{...}) and r...", "B_clean_title": ["wip", "add", "method", "option", "rng", "argument", "rand", "rng", "array"], "A_body": "The diffs for the docs update are probably easier to read with \"Split\" diff (instead of \"Unified\"). I tentatively merged the two docs for `rand` into one text, but comments are welcome.\n", "A_clean_body": ["diff", "doc", "updat", "are", "probabl", "easier", "read", "split", "diff", "instead", "unifi", "tent", "merg", "two", "doc", "rand", "into", "one", "text", "but", "comment", "are", "welcom"], "B_body": "...and!([rng], Array{...}) that create arrays\n\nFor some reason, dsfmt_fill_array with state is not deterministic in my tests right now?\n", "B_clean_body": ["rng", "array", "that", "creat", "array", "some", "reason", "dsfmt", "fill", "array", "state", "not", "determinist", "my", "test", "right", "now"], "title_sim": [0.7338304488303656], "body_sim": [0.0286287296997593], "file_list_sim": 1.0, "overlap_files_len": 3, "code_sim": [0.0, 0.0], "location_sim": [0.16766467065868262, 0.16766467065868262], "pattern": 0, "time": 253}, {"A_title": "Fix build for LLVM 4.0 after r277386", "A_clean_title": ["fix", "build", "llvm", "after", "r277386"], "B_title": "Fix compilation on LLVM 4.0", "B_clean_title": ["fix", "compil", "llvm"], "A_body": "In r277386 \"[ExecutionEngine][MCJIT][Orc] Replace RuntimeDyld::SymbolInfo with JITSymbol.\" RuntimeDyld::SymbolInfo was removed, JITSymbol was moved outside the orc namespace and a new JITEvaluatedSymbol was introduced that resembles the original behaviour of RuntimeDyld::SymbolInfo.\n", "A_clean_body": ["r277386", "executionengin", "execut", "engin", "mcjit", "orc", "replac", "runtimedyld", "runtim", "dyld", ":symbolinfo", ":symbol", "info", "jitsymbol", "jit", "symbol", "runtimedyld", "runtim", "dyld", ":symbolinfo", ":symbol", "info", "wa", "remov", "jitsymbol", "jit", "symbol", "wa", "move", "outsid", "orc", "namespac", "new", "jitevaluatedsymbol", "jit", "evalu", "symbol", "wa", "introduc", "that", "resembl", "origin", "behaviour", "runtimedyld", "runtim", "dyld", ":symbolinfo", ":symbol", "info"], "B_body": "Renaming of `orc::JITSymbol` and `RuntimeDyld::SymbolInfo`.\n\nRef https://github.com/llvm-mirror/llvm/commit/075c1e2e1aa2a1fc577cb92ab40a260e45929984\n", "B_clean_body": ["renam", "orc", ":jitsymbol", ":jit", "symbol", "runtimedyld", "runtim", "dyld", ":symbolinfo", ":symbol", "info", "ref", "http", "mirror", "llvm", "commit", "075c1e2e1aa2a1fc577cb92ab40a260e45929984", "github", "com", "llvm"], "title_sim": [0.6080736576094179], "body_sim": [0.3764214992556835], "file_list_sim": 1.0, "overlap_files_len": 2, "code_sim": [0.8065967265162294, 0.8065967265162294], "location_sim": [0.7317073170731707, 0.7317073170731707], "pattern": 1, "time": 0}, {"A_title": "Add missing promote_op method for Nullable", "A_clean_title": ["add", "miss", "promot", "op", "method", "nullabl"], "B_title": "Add promotion rules for Nullable", "B_clean_title": ["add", "promot", "rule", "nullabl"], "A_body": "I noticed that these promotion methods were missing for `Nullable` types when working with the following code:\n\n``` julia\njulia> using NullableArrays\n\njulia> NullableArray([DateTime(2016)]) - NullableArray([DateTime(2015)])\nERROR: MethodError: Cannot `convert` an object of type Base.Dates.Millisecond to an object of type DateTime\nThis may have arisen from a call to the constructor DateTime(...),\nsince type constructors fall back to convert methods.\nClosest candidates are:\n  convert(::Type{DateTime}, ::Date)\n  convert{R<:Real}(::Type{DateTime}, ::R<:Real)\n  convert{T}(::Type{T}, ::T)\n  ...\n [inlined code] from ./nullable.jl:40\n in -(::NullableArrays.NullableArray{DateTime,1}, ::NullableArrays.NullableArray{DateTime,1}) at ./arraymath.jl:85\n in eval(::Module, ::Any) at ./boot.jl:236\n```\n\nThese changes should be backported to 0.4. The `promote_op` test will need to be updated to work on 0.4 and 0.5.\n", "A_clean_body": ["notic", "that", "these", "promot", "method", "were", "miss", "nullabl", "type", "when", "work", "follow", "code", "julia", "julia", "nullablearray", "nullabl", "array", "julia", "nullablearray", "nullabl", "array", "datetim", "date", "time", "2016", "nullablearray", "nullabl", "array", "datetim", "date", "time", "2015", "error", "methoderror", "method", "error", "not", "convert", "object", "type", "base", "date", "millisecond", "object", "type", "datetim", "date", "time", "thi", "may", "have", "arisen", "call", "constructor", "datetim", "date", "time", "sinc", "type", "constructor", "fall", "back", "convert", "method", "closest", "candid", "are", "convert", ":type", "datetim", "date", "time", ":date", "convert", "real", ":type", "datetim", "date", "time", ":r", "real", "convert", ":type", ":t", "inlin", "code", "jl:40", "nullabl", ":nullablearray", "nullablearray", ":nullabl", "array", "nullabl", "array", "datetime,1", "date", "time,1", ":nullablearray", "nullablearray", ":nullabl", "array", "nullabl", "array", "datetime,1", "date", "time,1", "at", "jl:85", "arraymath", "eval", ":modul", ":ani", "at", "jl:236", "boot", "these", "chang", "backport", "promot", "op", "test", "will", "need", "updat", "work"], "B_body": "These are consistent with convert().\n\nCc: @johnmyleswhite\n", "B_clean_body": ["these", "are", "consist", "convert", "cc", "johnmyleswhit"], "title_sim": [0.5737801124136696], "body_sim": [0.2556590522737755], "file_list_sim": 1.0, "overlap_files_len": 2, "code_sim": [0.0, 0.0], "location_sim": [1.0, 1.0], "pattern": 0, "time": 11}]